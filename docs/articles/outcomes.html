<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Creation of model outcomes • kDGLM</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Creation of model outcomes">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">kDGLM</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.2.8</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/intro.html">Introduction</a></li>
    <li><a class="dropdown-item" href="../articles/structures.html">Creation of model structures</a></li>
    <li><a class="dropdown-item" href="../articles/outcomes.html">Creation of model outcomes</a></li>
    <li><a class="dropdown-item" href="../articles/fitting.html">Fitting and analysing models</a></li>
    <li><a class="dropdown-item" href="../articles/example1.html">Space-time model hospital admissions from gastroenteritis</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/silvaneojunior/kDGLM/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Creation of model outcomes</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/silvaneojunior/kDGLM/blob/HEAD/vignettes/outcomes.Rmd" class="external-link"><code>vignettes/outcomes.Rmd</code></a></small>
      <div class="d-none name"><code>outcomes.Rmd</code></div>
    </div>

    
    
<style>
body {
text-align: justify}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script><div class="section level2">
<h2 id="table-of-contents">Table of contents<a class="anchor" aria-label="anchor" href="#table-of-contents"></a>
</h2>
<ol>
<li>
<details><summary><a href="intro.html">Introduction:</a> &gt;
</summary><ul>
<li>
<a href="intro.html#introduction">Introduction</a>
</li>
<li>
<a href="intro.html#notation">Notation</a>
</li>
</ul></details>
</li>
<li>
<details><summary><a href="structures.html">Creating the model structure:</a> &gt;
</summary><ul>
<li>
<a href="structures.html#a-structure-for-polynomial-trend-models">A
structure for polynomial trend models</a>
</li>
<li>
<a href="structures.html#a-structure-for-dynamic-regression-models">A
structure for dynamic regression models</a>
</li>
<li>
<a href="structures.html#a-structure-for-harmonic-trend-models">A
structure for harmonic trend models</a>
</li>
<li>
<a href="structures.html#a-structure-for-autoregresive-models">A
structure for autoregresive models</a>
</li>
<li>
<a href="structures.html#a-structure-for-overdispersed-models">A
structure for overdispersed models</a>
</li>
<li>
<a href="structures.html#handling-multiple-structural-blocks">Handling
multiple structural blocks</a>
</li>
<li>
<a href="structures.html#handling-multiple-linear-predictors">Handling
multiple linear predictors</a>
</li>
<li>
<a href="structures.html#handling-unknown-components-in-the-planning-matrix-f_t">Handling
unknown components in the planning matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math></a>
</li>
<li>
<a href="structures.html#special-priors">Special priors</a>
</li>
</ul></details>
</li>
<li>
<details><summary><a href="outcomes.html">Creating the model outcome:</a> &gt;
</summary><ul>
<li>
<a href="outcomes.html#normal-case">Normal case</a>
</li>
<li>
<a href="outcomes.html#poisson-case">Poisson case</a>
</li>
<li>
<a href="outcomes.html#gamma-case">Gamma case</a>
</li>
<li>
<a href="outcomes.html#multinomial-case">Multinomial case</a>
</li>
<li>
<a href="outcomes.html#handling-multiple-outcomes">Handling multiple
outcomes</a>
</li>
</ul></details>
</li>
<li>
<details><summary><a href="fitting.html">Fitting and analysing models:</a> &gt;
</summary><ul>
<li>
<a href="fitting.html#filtering-and-smoothing">Filtering and
smoothing</a>
</li>
<li>
<a href="fitting.html#extracting-components">Extracting components</a>
</li>
<li>
<a href="fitting.html#forecasting">Forecasting</a>
</li>
<li>
<a href="fitting.html#intervention-and-monitoring">Intervention and
monitoring</a>
</li>
<li>
<a href="fitting.html#tools-for-sensibility-analysis">Tools for
sensibility analysis</a>
</li>
<li>
<a href="fitting.html#sampling-and-hyper-parameter-estimation">Sampling
and hyper parameter estimation</a>
</li>
</ul></details>
</li>
<li>
<details><summary>
Advanced examples:&gt;
</summary><ul><li>
<a href="example1.html">Space-time model hospital admissions from
gastroenteritis</a>
</li></ul></details>
</li>
</ol>
</div>
<div class="section level2">
<h2 id="creation-of-model-outcomes">Creation of model outcomes<a class="anchor" aria-label="anchor" href="#creation-of-model-outcomes"></a>
</h2>
<p>We have presented the tools for creating the structure of a DGLM
model, specifically, we have shown how to define the relationship
between the latent vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\theta}_t</annotation></semantics></math>
and the linear predictors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>λ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\lambda}_t</annotation></semantics></math>,
along with the temporal dynamic of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\theta}_t</annotation></semantics></math>.
Now we proceed to define the observational model for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{Y}_t</annotation></semantics></math>
and the relationship between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>λ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\lambda}_t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>η</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\eta}_t</annotation></semantics></math>,
i.e., the highlighted part of the following equations:</p>
<p><span class="math display">$$
\require{color}
\begin{equation}\begin{aligned}
\color{red}{Y_t|\eta_t }&amp;{\color{red}\sim
\mathcal{F}\left(\eta_t\right),}\\
{\color{red}g(\eta_t) }&amp;{\color{red}= \lambda_{t}}=F_t'\theta_t,\\
\theta_t &amp;=G_t\theta_{t-1}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_n(h_t,W_t),
\end{aligned}\end{equation}
$$</span></p>
<p>In each subsection, we will assume that the linear predictors are
already defined, along with all the structure that comes along with them
(i.e., we will take for granted the part of the model that is not
highlighted), moreover, we also assume that the user has created the
necessary amount of linear predictors for each type of outcome and that
those linear predictors were named as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\lambda_1</annotation></semantics></math>,…,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\lambda_k</annotation></semantics></math>.</p>
<p>Currently, we offer support for the following observational
distributions:</p>
<ul>
<li>Normal distribution with unknown mean and unknown variance (with
dynamic predictive structure for both parameters). As a particular case,
we also have support for Normal distribution with known variance.</li>
<li>Bivariate Normal distribution with unknown means, unknown variances
and unknown correlation (with dynamic predictive structure for all
parameters). As a particular case, we also have support for Multivariate
Normal distribution with known covariance matrix.</li>
<li>Poisson distribution with unknown rate parameter with dynamic
predictive structure.</li>
<li>Multinomial distribution with an known number of trials, arbitrary
number of categories, but unknown event probabilities with dynamic
predictive structure for the probability of each category. As particular
cases, we support the Binomial and Bernoulli distributions.</li>
<li>Gamma distribution with known shape parameter, but unknown mean with
dynamic predictive structure.</li>
</ul>
<p>We are currently working to include several distributions. In
particular, the following distributions shall be supported very soon:
Dirichlet; Geometric; Negative Binomial; Rayleigh; Pareto; Asymmetric
Laplace with known mean.</p>
</div>
<div class="section level2">
<h2 id="normal-case">Normal case<a class="anchor" aria-label="anchor" href="#normal-case"></a>
</h2>
<p>In some sense, we can think of this as the most basic case, at least
in a theoretical point of view, since the Kalman Filter was first
developed for this specific scenario <span class="citation">(<a href="#ref-Kalman_filter_origins">Kalman, 1960</a>)</span>. Indeed, if
we have a <strong>static</strong> observational variance/covariance
matrix (even if unknown), we fall within the DLM class, which has an
exact analytical solution for the posterior of the latent states. With
some adaptations, one can also have some degree of temporal dynamic for
the variance/covariance matrix <span class="citation">(see <a href="#ref-ameen1985discount">Ameen and Harrison, 1985</a>; <a href="#ref-WestHarr-DLM">West and Harrison, 1997, sec. 10.8</a>)</span>.
Yet, the <strong>kDGLM</strong> package goes a step further, offering
the possibility for predictive structure for both the mean and the
observational variance/covariance matrix, allowing the inclusion of
dynamic regressions, seasonal trends, autoregressive components, etc.,
for <strong>both</strong> parameters.</p>
<p>We will present this case in two contexts: the first, which is a
simple implementation of the Kalman Filter and Smoother, deals with data
coming from an Normal distribution (possibly multivariate) with unknown
mean and known variance/covariance matrix; the second deals with data
coming from a univariate Normal distribution with unknown mean and
unknown variance.</p>
<p>Also, at the end of the second subsection, we present an extension to
the bivariated Normal distribution with unknown mean and unknown
covariance matrix. A study is being conducted to expand this approach to
the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-variated
case, for any arbitrary
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>.</p>
<div class="section level3">
<h3 id="normal-outcome-with-known-variance">Normal outcome with known variance<a class="anchor" aria-label="anchor" href="#normal-outcome-with-known-variance"></a>
</h3>
<p>Suppose that we have a sequence of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-dimensional
vectors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{Y}_t</annotation></semantics></math>,
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mn>1</mn><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>Y</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\vec{Y}_t=(Y_{1t},...,Y_{kt})'</annotation></semantics></math>.
We assume that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>μ</mi><mi>t</mi></msub><mo>,</mo><mi>V</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>μ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo>,</mo><mi>V</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>μ</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>k</mi><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\vec{Y}_t|\mu_t,V &amp;\sim \mathcal{N}_k\left(\vec{\mu}_t,V\right),\\
\mu_{it}&amp;=\lambda_{it}, i=1,...,k,\\
\end{aligned}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>μ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>μ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>μ</mi><mrow><mi>k</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\vec{\mu}_t=(\mu_{1,t},...,\mu_{k,t})'</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is a known symmetric, definite positive
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>×</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">k\times k</annotation></semantics></math>
matrix. Also, for this model, we assume that the link function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>
is the identity function.</p>
<p>To create the outcome for this model, we can make use of the
<code>Normal</code> function:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Normal.html">Normal</a></span><span class="op">(</span><span class="va">mu</span>, V <span class="op">=</span> <span class="cn">NA</span>, Tau <span class="op">=</span> <span class="cn">NA</span>, Sd <span class="op">=</span> <span class="cn">NA</span>, <span class="va">data</span><span class="op">)</span></span></code></pre></div>
<p>Intuitively, the <code>mu</code> argument must be a character vector
of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
containing the names of the linear predictors associated with each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mrow><mi>i</mi><mi>.</mi></mrow></msub><annotation encoding="application/x-tex">\mu_{i.}</annotation></semantics></math>.
The user must also specify one (and only one) of <code>V</code>,
<code>Tau</code> or <code>Sd</code>. If the user provides
<code>V</code>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is assumed to be that value; if the user provides <code>Tau</code>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is assumed to be the inverse of the given matrix (i.e., <code>Tau</code>
is the precision matrix); if the user provides <code>Sd</code>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is assumed to be such that the standard deviation of the observations is
equal to the main diagonal of <code>Sd</code> and the correlation
between observations is assumed the be equal to the off-diagonal
elements of <code>Sd</code>.</p>
<p>The <code>data</code> argument must be a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>×</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">T \times k</annotation></semantics></math>
matrix containing the values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{Y}_t</annotation></semantics></math>
for each observation. Notice that each line
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
must have the values of all categories in time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
and each column
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
must represent the values of a category
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
through time. If a value of the argument <code>data</code> is not
available (<code>NA</code>) for a specific time, it is assumed that
there was no observation at that time, thus the update step of the
filtering algorithm will be skipped at that time. Note that the
evolution step will still be performed, such that the predictive
distribution for the missing data and the updated distribution for the
latent states at that time will still be provided.</p>
<p>Next, we present a brief example for the usage of <code>Normal</code>
function for a univariate outcome (the multivariate case works
similarly). We use some functions described in the previous sections, as
well as some functions that will be presented later on. For now, let us
focus on the usage of the <code>Normal</code> function.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">level</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span>, order <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">season</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, D <span class="op">=</span> <span class="fl">0.975</span><span class="op">)</span></span>
<span></span>
<span><span class="va">outcome</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normal.html">Normal</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="st">"mu"</span>, V <span class="op">=</span> <span class="fl">6e-3</span>,</span>
<span>  data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">AirPassengers</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">fitted.model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">level</span>, <span class="va">season</span>, <span class="va">outcome</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.model</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="outcomes_files/figure-html/unnamed-chunk-3-1.png" width="672"></p>
<p>Notice that, since this is the univariate case, the <code>data</code>
argument can be a vector.</p>
</div>
<div class="section level3">
<h3 id="univariated-normal-outcome-with-unknown-variance">Univariated Normal outcome with unknown variance<a class="anchor" aria-label="anchor" href="#univariated-normal-outcome-with-unknown-variance"></a>
</h3>
<p>For this type of outcome, we assume that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>μ</mi><mi>t</mi></msub><mo>,</mo><msub><mi>τ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>μ</mi><mi>t</mi></msub><mo>,</mo><msubsup><mi>τ</mi><mi>t</mi><mrow><mi>−</mi><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>μ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mrow><mn>1</mn><mi>t</mi></mrow></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>τ</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">}</mo></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mrow><mn>2</mn><mi>t</mi></mrow></msub><mi>.</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
Y_t|\mu_t,\tau_t &amp;\sim \mathcal{N}\left(\mu_t,\tau_t^{-1}\right),\\
\mu_{t}&amp;=\lambda_{1t},\\
\ln\{\tau_{t}\}&amp;=\lambda_{2t}.\\
\end{aligned}
</annotation></semantics></math></p>
<p>To create an outcome for this model, we also make use of the
<code>Normal</code> function:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Normal.html">Normal</a></span><span class="op">(</span><span class="va">mu</span>, V <span class="op">=</span> <span class="cn">NA</span>, Tau <span class="op">=</span> <span class="cn">NA</span>, Sd <span class="op">=</span> <span class="cn">NA</span>, <span class="va">data</span><span class="op">)</span></span></code></pre></div>
<p>Just as before, the <code>mu</code> argument must be a character
representing the label of the linear predictor associated with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\mu_t</annotation></semantics></math>.
The user must also specify one (and only one) of <code>V</code>,
<code>Tau</code> or <code>Sd</code>, which must be a character string
representing the label of the associated linear predictor.</p>
<p>Similar to the known variance case, we allow multiple
parametrizations of the observational variance. Specifically, if the
user provides <code>V</code>, we assume that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mn>2</mn><mi>t</mi></mrow></msub><mo>=</mo><mo>ln</mo><mo stretchy="false" form="prefix">{</mo><msubsup><mi>σ</mi><mi>t</mi><mn>2</mn></msubsup><mo stretchy="false" form="postfix">}</mo><mo>=</mo><mi>−</mi><mo>ln</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>τ</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\lambda_{2t}=\ln\{\sigma^2_{t}\}=-\ln\{\tau_t\}</annotation></semantics></math>;
if the user provides <code>Sd</code>, we assume that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mn>2</mn><mi>t</mi></mrow></msub><mo>=</mo><mo>ln</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">}</mo><mo>=</mo><mi>−</mi><mo>ln</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>τ</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">}</mo><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\lambda_{2t}=\ln\{\sigma_{t}\}=-\ln\{\tau_t\}/2</annotation></semantics></math>;
if the user provides <code>Tau</code>, then the default parametrization
is used, i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mn>2</mn><mi>t</mi></mrow></msub><mo>=</mo><mo>ln</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>τ</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\lambda_{2t}=\ln\{\tau_t\}</annotation></semantics></math>.</p>
<p>The <code>data</code> argument usually is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T \times 1</annotation></semantics></math>
matrix containing the values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>
for each observation. In cases where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{Y}_t</annotation></semantics></math>
is univariated, we also accept <code>data</code> as a line vector, in
which case we assume that each coordinate of <code>data</code>
represents the observed value at each time. If a value of data is not
available (<code>NA</code>) for a specific time, it is assumed that
there was no observation at that time, thus the update step of the
filtering algorithm will be skipped at that time. Note that the
evolution step will still be performed, such that the predictive
distribution for the missing data and the updated distribution for the
latent states at that time will still be provided.</p>
<p>Next, we present a brief example for the usage of this outcome. We
use some functions described in the previous sections, as well as some
functions that will be presented later on. For now, let us focus on the
usage of the <code>Normal</code> function.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">structure</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>V <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span></span>
<span><span class="va">outcome</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normal.html">Normal</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="st">"mu"</span>, V <span class="op">=</span> <span class="st">"V"</span>, data <span class="op">=</span> <span class="va">cornWheat</span><span class="op">$</span><span class="va">corn.log.return</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">500</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">fitted.model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">structure</span>, <span class="va">outcome</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.model</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="outcomes_files/figure-html/unnamed-chunk-5-1.png" width="672"></p>
<p>Currently, we also support models with bivariate Normal outcomes. In
this scenario we assume the following model:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>μ</mi><mi>t</mi></msub><mo>,</mo><msub><mi>V</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>μ</mi><mi>t</mi></msub><mo>,</mo><msub><mi>V</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>μ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>μ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>μ</mi><mrow><mn>2</mn><mi>t</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>V</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msubsup><mi>τ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msubsup></mtd><mtd columnalign="center" style="text-align: center"><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>τ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><msub><mi>τ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msup><msub><mi>ρ</mi><mi>t</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>τ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><msub><mi>τ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msup><msub><mi>ρ</mi><mi>t</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><msubsup><mi>τ</mi><mn>2</mn><mrow><mi>−</mi><mn>1</mn></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>μ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>τ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mo>ln</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>λ</mi><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ρ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mo>tanh</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>λ</mi><mrow><mn>5</mn><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
Y_t|\mu_{t},V_t &amp;\sim \mathcal{N}_2\left(\mu_t,V_t\right),\\
\mu_t&amp;=\begin{bmatrix}\mu_{1,t}\\ \mu_{2t}\end{bmatrix},\\
V_t&amp;=\begin{bmatrix}\tau_{1,t}^{-1} &amp; (\tau_{1,t}\tau_{2,t})^{-1/2}\rho_t\\ (\tau_{1,t}\tau_{2,t})^{-1/2}\rho_t &amp; \tau_2^{-1}\end{bmatrix},\\
\mu_{i,t}&amp;=\lambda_{i,t}, i=1,2\\
\tau_{i,t}&amp;=\ln\{\lambda_{(i+2),t}\}, i=1,2\\
\rho_{t}&amp;=\tanh\{\lambda_{5,t}\}.\\
\end{aligned}
</annotation></semantics></math></p>
<p>Notice that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\rho_t</annotation></semantics></math>
represents the (and the covariance) between the series at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
To guarantee that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mi>t</mi></msub><mo>∈</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\rho_t \in (-1,1)</annotation></semantics></math>,
we use the Inverse Fisher transformation (also known as the hyperbolic
tangent function) as link function.</p>
<p>For those models, `<code>mu</code> must be a character vector,
similarly to the case where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>
is known, and <code>V</code>, <code>Tau</code> and <code>Sd</code> must
be a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math>
character matrix. The main diagonal elements are interpreted as the
linear predictors associated with the precisions, variances or standard
deviations, depending if the user used <code>Tau</code>, <code>V</code>
or <code>Sd</code>, respectively. The off diagonal elements must be
equals (one of them can be <code>NA</code>) and will be interpreted as
the linear predictor associated with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\rho_t</annotation></semantics></math>.</p>
<p>Bellow we present an example for the bivariate case:</p>
<div class="section level4">
<h4 class="tabset" id="section"></h4>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Bivariate Normal case</span></span>
<span><span class="va">structure</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>log.V <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span><span class="op">)</span> <span class="op">*</span> <span class="fl">2</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>atanh.rho <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span></span>
<span><span class="va">outcome</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Normal.html">Normal</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mu.1"</span>, <span class="st">"mu.2"</span><span class="op">)</span>,</span>
<span>  V <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"log.V.1"</span>, <span class="st">"atanh.rho"</span>, <span class="st">"atanh.rho"</span>, <span class="st">"log.V.2"</span><span class="op">)</span>, <span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">cornWheat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">500</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">5</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="op">)</span></span>
<span><span class="va">fitted.model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">structure</span>, <span class="va">outcome</span><span class="op">)</span></span></code></pre></div>
<div class="section level5">
<h5 id="predictions">Predictions<a class="anchor" aria-label="anchor" href="#predictions"></a>
</h5>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.model</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="outcomes_files/figure-html/unnamed-chunk-7-1.png" width="672"></p>
</div>
<div class="section level5">
<h5 id="correlation">Correlation<a class="anchor" aria-label="anchor" href="#correlation"></a>
</h5>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.model</span>, linear.predictors <span class="op">=</span> <span class="st">"atanh.rho"</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="outcomes_files/figure-html/unnamed-chunk-8-1.png" width="672"></p>
</div>
</div>
<p>Notice that, by the second plot, the correlation between the series
(represented by <code>atanh.rho</code>, i.e., the plot shows
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>tanh</mo><mrow><mi>−</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>ρ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\tanh^{-1}(\rho)</annotation></semantics></math>)
is significant and changes over time, making the proposed model much
more adequate than two independent Normal models (one for each
outcome).</p>
</div>
</div>
<div class="section level2">
<h2 id="poisson-case">Poisson case<a class="anchor" aria-label="anchor" href="#poisson-case"></a>
</h2>
<p>In this case, we assume the following observational model:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>η</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mi>t</mi></msub><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}\begin{aligned}
Y_t|\eta_t &amp;\sim Poisson\left(\eta_t\right),\\
\ln(\eta_t) &amp;=\lambda_{t}.
\end{aligned}\end{equation}
</annotation></semantics></math></p>
<p>In the notation introduced before, we have that our link function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>
is the (natural) logarithm function.</p>
<p>To define such observational model, we offer the <code>Poisson</code>
function, whose usage is presented bellow:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span><span class="va">lambda</span>, <span class="va">data</span>, offset <span class="op">=</span> <span class="va">data</span><span class="op">^</span><span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p>As usual in the literature, we refer to the rate parameter of the
Poisson distribution as <code>lambda</code> (although, in the context of
this document, this might seem confusing) and the user must provide for
this argument the name of the linear predictor associated with this
parameter.</p>
<p>For the argument <code>data</code> the user must provide a sequence
of numerical values consisting of the observed values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>
at each time. Since the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>
is a scalar for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
the user can pass the outcome as a vector or as a matrix with a single
column. If a value of <code>data</code> is not available
(<code>NA</code>) for a specific time, it is assumed that there was no
observation at that time, thus the update step of the filtering
algorithm will be skipped at that time. Note that the evolution step
will still be performed, such that the predictive distribution for the
missing data and the updated distribution for the latent states at that
time will still be provided.</p>
<p>Lastly, the <code>offset</code> argument is optional and can be used
to provide a measure of the scale of the data. If the offset is provided
and is equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mi>t</mi></msub><annotation encoding="application/x-tex">E_t</annotation></semantics></math>,
then we will fit a model assuming that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>θ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><msub><mi>E</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mi>t</mi></msub><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}\begin{aligned}
Y_t|\theta_t &amp;\sim Poisson\left(\eta_tE_t\right),\\
\ln(\eta_t) &amp;=\lambda_{t}.
\end{aligned}\end{equation}
</annotation></semantics></math></p>
<p>Bellow we present an example of the usage of this outcome. We use
some functions described in the previous section, as well as some
functions that will present later on, for now, let us focus only on the
usage of the <code>Poisson</code> function.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">AirPassengers</span><span class="op">)</span></span>
<span></span>
<span><span class="va">level</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>rate <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">2</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span><span class="va">season</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>rate <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, order <span class="op">=</span> <span class="fl">2</span>, D <span class="op">=</span> <span class="fl">0.975</span><span class="op">)</span></span>
<span></span>
<span><span class="va">outcome</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"rate"</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">level</span>, <span class="va">season</span>,</span>
<span>  AirPassengers <span class="op">=</span> <span class="va">outcome</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.data</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="outcomes_files/figure-html/unnamed-chunk-10-1.png" width="672"></p>
<p>Notice that, while creating the structure, we defined a linear
predictor named <code>rate</code>, whose behavior is being explained by
a second order polynomial trend and seasonal component defined by a
second order harmonic block. Since the value passed to <code>rate</code>
equals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
in both blocks, we have that these components have a constant effect
(and equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>)
on the linear predictor on all times, although <strong>the components
themselves change their values over time</strong> such as to capture the
behavior of the series.</p>
<p>Later on, when creating the outcome, we pass the name
<code>'rate'</code> as the linear predictor associated with
<code>lambda</code>, the rate (or mean) parameter of the Poisson
distribution.</p>
<p>This is a particularly simply usage of the package, the Poisson
kernel being the one with the smallest amount of parameters. Moving
forward, we will present outcomes whose specification can be a bit more
complex.</p>
</div>
<div class="section level2">
<h2 id="gamma-case">Gamma case<a class="anchor" aria-label="anchor" href="#gamma-case"></a>
</h2>
<p>In this subsection we will present the Gamma case, in which we assume
the following observational model:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>α</mi><mi>t</mi></msub><mo>,</mo><msub><mi>β</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>𝒢</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>t</mi></msub><mo>,</mo><msub><mi>β</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>α</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">}</mo></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mrow><mn>1</mn><mi>t</mi></mrow></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>β</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">}</mo></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mrow><mn>2</mn><mi>t</mi></mrow></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}\begin{aligned}
Y_t|\alpha_t,\beta_t &amp;\sim \mathcal{G}\left(\alpha_t,\beta_t\right),\\
\ln\{\alpha_t\}&amp;=\lambda_{1t},\\
\ln\{\beta_t\}&amp;=\lambda_{2t}
\end{aligned}\end{equation}
</annotation></semantics></math></p>
<p>For this outcome we have a few variations. First, there’s a matter of
parametrization. We allow the user to define the model by any non
redundant pair of:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>α</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>β</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ϕ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>α</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>μ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><msub><mi>α</mi><mi>t</mi></msub><msub><mi>β</mi><mi>t</mi></msub></mfrac><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>σ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mn>1</mn><msub><mi>β</mi><mi>t</mi></msub></mfrac><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}\begin{aligned}
\alpha_t&amp;,\\
\beta_t&amp;,\\
\phi_t&amp;=\alpha_t,\\
\mu_t&amp;=\frac{\alpha_t}{\beta_t},\\
\sigma_t&amp;=\frac{1}{\beta_t}.
\end{aligned}\end{equation}
</annotation></semantics></math></p>
<p>Naturally, the user <strong>CANNOT</strong> specify both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\alpha_t</annotation></semantics></math>
AND
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\beta_t</annotation></semantics></math>
AND
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\sigma_t</annotation></semantics></math>,
as such specification is redundant at best, and incoherent at worst.
Outside of those cases, in which the package will raise an error, any
combination can be used by the user, allowing for the structure of the
model to be defined within the variables that are most convenient (it
may be easier or more intuitive to specify the structure in the mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\mu_t</annotation></semantics></math>
and the scale
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\sigma_t</annotation></semantics></math>,
than on the shape
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\alpha_t</annotation></semantics></math>
and rate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\beta_t</annotation></semantics></math>).</p>
<p>Another particularity of the Gamma outcome is that the user may set
the shape parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
to a known constant. In that case, the user must specify the structure
to the mean parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\mu_t</annotation></semantics></math>
(he is not allowed to specify neither
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\beta_t</annotation></semantics></math>
nor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\sigma_t</annotation></semantics></math>).
In general, we do not expect the shape parameter to be known, still,
there are some important applications where it is common the use some
particular cases of the Gamma distribution, such as the Exponential
Model
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\phi_t=1</annotation></semantics></math>)
or the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>χ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\chi^2</annotation></semantics></math>
model
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>t</mi></msub><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\phi_t=0.5</annotation></semantics></math>).
The estimation of the shape parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
is still under development, as such, the current version of the package
does not have support for a unknown
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
(a version of the package with a proper estimation for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
will be released very soon).</p>
<p>No matter the parametrization, the link function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>
will always be the logarithm function, as such, given a certain
parametrization, we can write the linear predictor of any other
parametrization as a linear transformation of the original.</p>
<p>In the examples of this section, we will always use the parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
(when applicable) and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\mu_t</annotation></semantics></math>,
but the code used can be trivially adapted to other
parametrizations.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Gamma.html">Gamma</a></span><span class="op">(</span>phi <span class="op">=</span> <span class="cn">NA</span>, mu <span class="op">=</span> <span class="cn">NA</span>, alpha <span class="op">=</span> <span class="cn">NA</span>, beta <span class="op">=</span> <span class="cn">NA</span>, sigma <span class="op">=</span> <span class="cn">NA</span>, data <span class="op">=</span> , offset <span class="op">=</span> <span class="va">data</span><span class="op">^</span><span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p>Similar to the Poisson case, the argument <code>data</code> must
provide a set of numerical values consisting of the observed values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>
at each time. Since the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>
is a scalar for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
the user can pass the outcome either as a vector or as a matrix with a
single column. If a value of the argument <code>data</code> is not
available (<code>NA</code>) for a specific time, it is assumed that
there was no observation at that time, thus the update step of the
filtering algorithm will be skipped at that time. Note that the
evolution step will still be performed, such that the predictive
distribution for the missing data and the updated distribution for the
latent states at that time will still be provided.</p>
<p>The <code>offset</code> argument is optional and can be used to
provide a measure of the scale of the data. If the offset is provided
and is equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mi>t</mi></msub><annotation encoding="application/x-tex">E_t</annotation></semantics></math>,
then we will fit a model assuming that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>θ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>𝒢</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>α</mi><mi>t</mi></msub><mo>,</mo><msub><mi>β</mi><mi>t</mi></msub><msubsup><mi>E</mi><mi>t</mi><mrow><mi>−</mi><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}\begin{aligned}
Y_t|\theta_t &amp;\sim \mathcal{G}\left(\alpha_t,\beta_t E_t^{-1}\right).
\end{aligned}\end{equation}
</annotation></semantics></math></p>
<p>Note that the above model implies that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>θ</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mfrac><msub><mi>α</mi><mi>t</mi></msub><msub><mi>β</mi><mi>t</mi></msub></mfrac><msub><mi>E</mi><mi>t</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
\mathbb{E}[Y_t|\theta_t]=\frac{\alpha_t}{\beta_t}E_t.
</annotation></semantics></math></p>
<p>The arguments <code>phi</code>, <code>mu</code>, <code>alpha</code>,
<code>beta</code> and <code>sigma</code> should be character strings
indicating the name of the linear predictor associated with their
respective linear predictor. The user may opt to pass <code>phi</code>
as a positive numerical value, it that case, the shape parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
is considered known and equal to <code>phi</code> for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">structure</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span><span class="va">Y</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">cornWheat</span><span class="op">$</span><span class="va">corn.log.return</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">500</span><span class="op">]</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">cornWheat</span><span class="op">$</span><span class="va">corn.log.return</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">500</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">**</span><span class="fl">2</span></span>
<span></span>
<span><span class="va">outcome</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Gamma.html">Gamma</a></span><span class="op">(</span>phi <span class="op">=</span> <span class="fl">0.5</span>, mu <span class="op">=</span> <span class="st">"mu"</span>, data <span class="op">=</span> <span class="va">Y</span><span class="op">)</span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">structure</span>, <span class="va">outcome</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.data</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="outcomes_files/figure-html/unnamed-chunk-12-1.png" width="672"></p>
</div>
<div class="section level2">
<h2 id="multinomial-case">Multinomial case<a class="anchor" aria-label="anchor" href="#multinomial-case"></a>
</h2>
<p>Let us assume that we have a sequence of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-dimensional
non-negative integer vectors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>,
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mn>1</mn><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>Y</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">Y_t=(Y_{1t},...,Y_{kt})'</annotation></semantics></math>
and:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>N</mi><mi>t</mi></msub><mo>,</mo><msub><mover><mi>p</mi><mo accent="true">→</mo></mover><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>M</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>N</mi><mi>t</mi></msub><mo>,</mo><msub><mover><mi>p</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><msub><mi>p</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub></mfrac><mo stretchy="true" form="postfix">}</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>N</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>Y</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}\begin{aligned}
Y_t|N_t,\vec{p}_t &amp;\sim Multinom\left(N_t,\vec{p}_t\right),\\
\ln\left\{\frac{p_{it}}{p_{kt}}\right\}&amp;=\lambda_{it}, i=1,...,k-1,\\
N_t&amp;=\sum_{i=1}^{k}Y_{it},
\end{aligned}\end{equation}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>p</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mrow><mn>1</mn><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>p</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\vec{p}_t=(p_{1t},...,p_{kt})'</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>&gt;</mo><mn>0</mn><mo>,</mo><mo>∀</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">p_{it} &gt; 0, \forall i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=1}^k p_{it}=1</annotation></semantics></math>.</p>
<p>Notice that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>t</mi></msub><annotation encoding="application/x-tex">N_t</annotation></semantics></math>
is automatically defined by the values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>,
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>t</mi></msub><annotation encoding="application/x-tex">N_t</annotation></semantics></math>
is always considered a known parameter. Also, it is important to point
out that this model has only
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math>
free parameters (instead of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>),
since the restriction
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=1}^k p_{it}=1</annotation></semantics></math>
implies that defining
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math>
entries of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>p</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{p}_t</annotation></semantics></math>
defines the remaining value. Specifically, we will always take the last
entry (or category) of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>
as the reference value, such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">p_{kt}</annotation></semantics></math>
can be considered as the baseline probability of observing data from a
category (i.e., we will model how each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">p_{it}</annotation></semantics></math>
relates to the baseline probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">p_{kt}</annotation></semantics></math>).</p>
<p>To create an outcome for this model, we can make use of the
<code>Multinom</code> function:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/Multinom.html">Multinom</a></span><span class="op">(</span><span class="va">p</span>, <span class="va">data</span>, offset <span class="op">=</span> <span class="va">data</span><span class="op">^</span><span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p>For the Multinomial case, <code>p</code> must be a character
<strong>vector</strong> of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math>
containing the names of the linear predictors associated with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ln</mo><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><msub><mi>p</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub></mfrac><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex">\ln\left\{\frac{p_{it}}{p_{kt}}\right\}</annotation></semantics></math>
for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1,...,k-1</annotation></semantics></math>.</p>
<p>The <code>data</code> argument must be a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>×</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">T \times k</annotation></semantics></math>
matrix containing the values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>
for each observation. Notice that each line
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
must represent the values of all categories in time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and each column
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
must represent the values of a category
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
through time. If a value of the argument <code>data</code> is not
available (<code>NA</code>) for a specific time, it is assumed that
there was no observation at that time, thus the update step of the
filtering algorithm will be skipped at that time. Note that the
evolution step will still be performed, such that the predictive
distribution for the missing data and the updated distribution for the
latent states at that time will still be provided.</p>
<p>The <code>offset</code> argument is optional and must have the same
dimensions of <code>data</code> (its dimensions are interpreted in the
same manner). The argument can be used to provide a measure of the scale
of the data and, if the offset is provided, such that, at each time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
the offset is equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>E</mi><mrow><mn>1</mn><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>E</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">E_t=(E_{1t},...,E_{kt})'</annotation></semantics></math>,
then we will fit a model assuming that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>θ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>M</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>N</mi><mi>t</mi></msub><mo>,</mo><msubsup><mover><mi>p</mi><mo accent="true">→</mo></mover><mi>t</mi><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><msubsup><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow><mo>*</mo></msubsup><msubsup><mi>p</mi><mrow><mi>k</mi><mi>t</mi></mrow><mo>*</mo></msubsup></mfrac><mo stretchy="true" form="postfix">}</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mo>ln</mo><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><msub><mi>p</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub></mfrac><mo stretchy="true" form="postfix">}</mo></mrow><mo>+</mo><mo>ln</mo><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><msub><mi>E</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><msub><mi>E</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub></mfrac><mo stretchy="true" form="postfix">}</mo></mrow><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>k</mi><mo>−</mo><mn>1</mn><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}\begin{aligned}
Y_t|\theta_t &amp;\sim Multinom\left(N_t,\vec{p}^*_t\right),\\
\ln\left\{\frac{p^*_{it}}{p^*_{kt}}\right\}&amp;=\ln\left\{\frac{p_{it}}{p_{kt}}\right\}+\ln\left\{\frac{E_{it}}{E_{kt}}\right\}, i=1,...,k-1.
\end{aligned}\end{equation}
</annotation></semantics></math></p>
<p>At the end of this subsection we present a brief discussion about the
implications of the inclusion of the offset and how to interpret it, as
well as a explanation for the way we chose to include it.</p>
<p>Again, we present a brief example for the usage of this outcome:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Multinomial case</span></span>
<span><span class="va">structure</span> <span class="op">&lt;-</span> <span class="op">(</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">2</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, D <span class="op">=</span> <span class="fl">0.975</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="../reference/noise_block.html">noise_block</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">1</span>, R1 <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span> <span class="op">+</span></span>
<span>    <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span>p <span class="op">=</span> <span class="va">chickenPox</span><span class="op">$</span><span class="va">date</span> <span class="op">&gt;=</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html" class="external-link">as.Date</a></span><span class="op">(</span><span class="st">"2013-09-01"</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="co"># Vaccine was introduced in September of 2013</span></span>
<span><span class="op">)</span> <span class="op">*</span> <span class="fl">4</span></span>
<span></span>
<span><span class="va">outcome</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Multinom.html">Multinom</a></span><span class="op">(</span>p <span class="op">=</span> <span class="va">structure</span><span class="op">$</span><span class="va">pred.names</span>, data <span class="op">=</span> <span class="va">chickenPox</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span>, <span class="fl">6</span>, <span class="fl">5</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">structure</span>, chickenPox <span class="op">=</span> <span class="va">outcome</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fitted.data</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.data</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="outcomes_files/figure-html/unnamed-chunk-14-1.png" width="672"></p>
<div class="section level3">
<h3 id="some-comments-on-the-usage-of-an-offset">Some comments on the usage of an offset<a class="anchor" aria-label="anchor" href="#some-comments-on-the-usage-of-an-offset"></a>
</h3>
<p>The model presented in this section is intend to describe a phenomena
such that we have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>t</mi></msub><annotation encoding="application/x-tex">N_t</annotation></semantics></math>
subjects that were distributed randomly (but not necessarily uniformly
randomly) among
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
categories. In this scenario,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">p_{it}</annotation></semantics></math>
represent the probability of one observation to fall within the category
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>=</mo><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>=</mo><mn>1</mn><mo stretchy="false" form="prefix">|</mo><msub><mi>N</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
p_{it}=\mathbb{P}(Y_{it}=1|N_t=1).
</annotation></semantics></math></p>
<p>In some applications, it might be the case that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>t</mi></msub><annotation encoding="application/x-tex">N_t</annotation></semantics></math>
represents the counting of some event of interest and we want to model
the probability of this event occurring in each category. In this
scenario, it is not clear how to use the multinomial model, since we
will have that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>=</mo><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo stretchy="false" form="prefix">|</mo><mtext mathvariant="normal">Event occured</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
p_{it}=\mathbb{P}(\text{Observation belong to category }i|\text{Event occured}),
</annotation></semantics></math> but we actually want to known:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow><mo>*</mo></msubsup><mo>=</mo><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Event occured</mtext><mo stretchy="false" form="prefix">|</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
p^*_{it}=\mathbb{P}(\text{Event occured}|\text{Observation belong to category }i).
</annotation></semantics></math></p>
<p>Notice that we can write:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow><mo>*</mo></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Event occured</mtext><mo stretchy="false" form="prefix">|</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo stretchy="false" form="prefix">|</mo><mtext mathvariant="normal">Event occured</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Event occured</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mrow><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Event occured</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
p^*_{it}&amp;=\mathbb{P}(\text{Event occured}|\text{Observation belong to category }i)\\
&amp;=\frac{\mathbb{P}(\text{Observation belong to category }i|\text{Event occured})\mathbb{P}(\text{Event occured})}{\mathbb{P}(\text{Observation belong to category }i)}\\
&amp;=\frac{p_{it}\mathbb{P}(\text{Event occured})}{\mathbb{P}(\text{Observation belong to category }i)}.
\end{aligned}
</annotation></semantics></math></p>
<p>The above relation implies that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><msubsup><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow><mo>*</mo></msubsup><msubsup><mi>p</mi><mrow><mi>k</mi><mi>t</mi></mrow><mo>*</mo></msubsup></mfrac><mo stretchy="true" form="postfix">}</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mo>ln</mo><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><msub><mi>p</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub></mfrac><mo stretchy="true" form="postfix">}</mo></mrow><mo>−</mo><mo>ln</mo><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo stretchy="true" form="postfix">}</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\ln\left\{\frac{p^*_{it}}{p^*_{kt}}\right\}
&amp;=\ln\left\{\frac{p_{it}}{p_{kt}}\right\}-\ln\left\{\frac{\mathbb{P}(\text{Observation belong to category }i)}{\mathbb{P}(\text{Observation belong to category }k)}\right\}.
\end{aligned}
</annotation></semantics></math></p>
<p>If we pass to the <code>offset</code> argument of the
<code>Multinom</code> function a set of values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mi>t</mi></msub><annotation encoding="application/x-tex">E_t</annotation></semantics></math>,
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>t</mi></msub><mo>∝</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">E_{t} \propto (\mathbb{P}(\text{Observation belong to category }1),...,\mathbb{P}(\text{Observation belong to category }k))'</annotation></semantics></math>,
then, by the specification provided in this section, we have that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ln</mo><mrow><mo stretchy="true" form="prefix">{</mo><mfrac><msubsup><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow><mo>*</mo></msubsup><msubsup><mi>p</mi><mrow><mi>k</mi><mi>t</mi></mrow><mo>*</mo></msubsup></mfrac><mo stretchy="true" form="postfix">}</mo></mrow><mo>=</mo><msub><mi>λ</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
\ln\left\{\frac{p^*_{it}}{p^*_{kt}}\right\}=\lambda_{it},
</annotation></semantics></math> in other words, the linear predictors
(and consequently, the model structure) will describe the probability
that an event occurs in a specific class (instead of the probability
that an observation belongs to that class, given the occurrence of the
event).</p>
<p>To obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow><mo>*</mo></msubsup><annotation encoding="application/x-tex">p^*_{it}</annotation></semantics></math>
itself (i.e. the probability of the event occurring given that the
observation belongs to the category
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>),
one can use Bayes formula, as long
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Event occured</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{P}(\text{Event occured})</annotation></semantics></math>
is known. Indeed, one can write:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow><mo>*</mo></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>p</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mfrac><mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Event occured</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mrow><mo>exp</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>λ</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><mrow><mn>1</mn><mo>+</mo><munder><mo>∑</mo><mi>j</mi></munder><mo>exp</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>λ</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow></mfrac><mfrac><mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">Event occured</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>ℙ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mtext mathvariant="normal">Observation belong to category </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
p^*_{it}&amp;=p_{it}\frac{\mathbb{P}(\text{Event occured})}{\mathbb{P}(\text{Observation belong to category }i)}\\
        &amp;=\frac{\exp\{\lambda_i\}}{1+\sum_j \exp\{\lambda_j\}}\frac{\mathbb{P}(\text{Event occured})}{\mathbb{P}(\text{Observation belong to category }i)}
\end{aligned}
</annotation></semantics></math></p>
</div>
</div>
<div class="section level2">
<h2 id="handling-multiple-outcomes">Handling multiple outcomes<a class="anchor" aria-label="anchor" href="#handling-multiple-outcomes"></a>
</h2>
<p>Lastly, the <strong>kDGLM</strong> package also allows for the user
to jointly fit multiple time series, as long as the marginal
distribution of each series is one of the supported distributions
<strong>AND</strong> the series are independent given the latent state
vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\theta}_t</annotation></semantics></math>.
In other words, let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></msubsup><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">\{\vec{Y}_{i,t}\}_{t=1}^{T}, i =1,...,r</annotation></semantics></math>,
be a set of time series such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mover><mi>η</mi><mo accent="true">→</mo></mover><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>ℱ</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>η</mi><mo accent="true">→</mo></mover><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>g</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>η</mi><mo accent="true">→</mo></mover><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mover><mi>λ</mi><mo accent="true">→</mo></mover><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mi>′</mi><msub><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\vec{Y}_{i,t}|\vec{\eta}_{i,t} &amp;\sim \mathcal{F}_{i}\left(\vec{\eta}_{i,t}\right),\\
g_i(\vec{\eta}_{i,t})&amp;=\vec{\lambda}_{i,t}=F_{i,t}'\vec{\theta}_{t},
\end{aligned}
</annotation></semantics></math> and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mrow><mi>r</mi><mo>,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\vec{Y}_{1,t}, ...,\vec{Y}_{r,t}</annotation></semantics></math>
are mutually independent given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>η</mi><mo accent="true">→</mo></mover><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mover><mi>η</mi><mo accent="true">→</mo></mover><mrow><mi>r</mi><mo>,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\vec{\eta}_{1,t}, ...,\vec{\eta}_{r,t}</annotation></semantics></math>.
Note that the observational distributions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℱ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{F}_i</annotation></semantics></math>
does not need to be the same for each outcome, as long as each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℱ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathcal{F}_i</annotation></semantics></math>
is within the supported marginal distributions. For example, we could
have three time series
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">r=3</annotation></semantics></math>),
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℱ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\mathcal{F}_1</annotation></semantics></math>
is a Poisson distribution,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℱ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">\mathcal{F}_2</annotation></semantics></math>
is Normal distribution with unknown mean and precision and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℱ</mi><mn>3</mn></msub><annotation encoding="application/x-tex">\mathcal{F}_3</annotation></semantics></math>
is a Gamma distribution with known shape. Also, this specification does
not impose any restriction on the model structure, such that each
outcome can have its own component, with polynomial, regression and
harmonic blocks, besides having shared components with each other. See
<span class="citation">(<a href="#ref-ArtigoMultivar">dos Santos et al.,
2024</a>)</span> for a detailed discussion of the approach used to model
multiple time series using kDGLMs.</p>
<p>To fit such model, one must only pass the outcomes to the
<code>fit_model</code> function. As an example, we present the code for
fitting two Poisson series:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">structure</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>mu.1 <span class="op">=</span> <span class="fl">1</span>, mu.2 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">2</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span> <span class="op">+</span> <span class="co"># Common factor</span></span>
<span>  <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>mu.2 <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, order <span class="op">=</span> <span class="fl">2</span>, D <span class="op">=</span> <span class="fl">0.975</span><span class="op">)</span> <span class="op">+</span> <span class="co"># Seasonality for Series 2</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>mu.2 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span> <span class="op">+</span> <span class="co"># Local level for Series 2</span></span>
<span>  <span class="fu"><a href="../reference/noise_block.html">noise_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">*</span> <span class="fl">2</span> <span class="co"># Overdispersion for both Series</span></span>
<span></span>
<span><span class="va">fitted.model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">structure</span>,</span>
<span>  Adults <span class="op">=</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"mu.1"</span>, data <span class="op">=</span> <span class="va">chickenPox</span><span class="op">[</span>, <span class="fl">5</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  Infants <span class="op">=</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"mu.2"</span>, data <span class="op">=</span> <span class="va">chickenPox</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.model</span><span class="op">)</span></span></code></pre></div>
<p>It is important to note that the Multivariate Normal and the
Multinomial cases are multivariated outcomes and are
<strong>not</strong> considered multiple outcomes on their own, but
instead, they are treated as one outcome each, such that the outcome
itself is a vector (note that we made no restrictions on the dimension
of each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\vec{Y}_{i,t}</annotation></semantics></math>).
As such, in those cases, the components of the vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Y</mi><mo accent="true">→</mo></mover><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\vec{Y}_{i,t}</annotation></semantics></math>
do not have to be mutually independent given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>η</mi><mo accent="true">→</mo></mover><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\vec{\eta}_{i,t}</annotation></semantics></math>.</p>
<p>Also important to note is that our general approach for modeling
multiple time series can not, on its own, be considered a generalization
of the Multivariate Normal or Multinomial models. Specifically, if we
treat each coordinate of the outcome as a outcome of its own, they would
<strong>not</strong> satisfy the hypotheses of independence given the
latent states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\theta}_t</annotation></semantics></math>.
This can be compensated with changes to the model structure, but, in
general, it is better to model data using a known joint distribution
than to assume conditional independence and model the outcomes
dependence by shared structure.</p>
<div class="section level3">
<h3 id="special-case-conditional-modelling">Special case: Conditional modelling<a class="anchor" aria-label="anchor" href="#special-case-conditional-modelling"></a>
</h3>
<p>There is a special type of specification for a model with multiple
outcomes that does not require the outcomes to be independent given the
latent states. Indeed, if the user specifies the conditional
distribution of each outcome given the previous ones, then no hypotheses
is needed for fitting the data.</p>
<p>For instance, lets say that there are three time series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><msub><mi>Y</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Y_{1,t},Y_{2,t}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">Y_{3,t}</annotation></semantics></math>,
such that each series follows a Poisson distribution with parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">\eta_{i,t}, i=1,2,3</annotation></semantics></math>.
Then,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mi>t</mi></msub><mo>=</mo><msub><mi>Y</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>Y</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>Y</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Z_t=Y_{1,t}+Y_{2,t}+Y_{3,t}</annotation></semantics></math>
follows a Poisson distribution with parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>η</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>η</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\eta_{1,t}+\eta_{2,t}+\eta_{3,t}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><msub><mi>Y</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><msub><mi>Y</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>Z</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">Y_{1,t},Y_{2,t},Y_{3,t}|Z_t</annotation></semantics></math>
jointly follows a Multinomial distribution with parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>t</mi></msub><mo>=</mo><msub><mi>Z</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">N_t=Z_t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>p</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msub><mi>η</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mrow><msub><mi>η</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>η</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>η</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></mfrac><mo>,</mo><mfrac><msub><mi>η</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mrow><msub><mi>η</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>η</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>η</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></mfrac><mo>,</mo><mfrac><msub><mi>η</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><mrow><msub><mi>η</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>η</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>η</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\vec{p}_t=\left(\frac{\eta_{1,t}}{\eta_{1,t}+\eta_{2,t}+\eta_{3,t}},\frac{\eta_{2,t}}{\eta_{1,t}+\eta_{2,t}+\eta_{3,t}},\frac{\eta_{3,t}}{\eta_{1,t}+\eta_{2,t}+\eta_{3,t}}\right)'</annotation></semantics></math>.
Then the user may model
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Z</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Z_t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><msub><mi>Y</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><msub><mi>Y</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>Z</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">Y_{1,t},Y_{2,t},Y_{3,t}|Z_t</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">structure</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">2</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, order <span class="op">=</span> <span class="fl">2</span>, D <span class="op">=</span> <span class="fl">0.975</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/noise_block.html">noise_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span> <span class="op">*</span> <span class="fl">2</span></span>
<span></span>
<span><span class="va">outcome1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"mu"</span>, data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">chickenPox</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">5</span><span class="op">)</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">outcome2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Multinom.html">Multinom</a></span><span class="op">(</span>p <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"p.1"</span>, <span class="st">"p.2"</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">chickenPox</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">5</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">structure</span>, Total <span class="op">=</span> <span class="va">outcome1</span>, Proportions <span class="op">=</span> <span class="va">outcome2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.model</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="outcomes_files/figure-html/unnamed-chunk-16-1.png" width="672"></p>
<p>See <span class="citation">Schmidt et al. (<a href="#ref-AlexMP">2022</a>)</span> for a discussion of
Multinomial-Poisson models. More applications are presented in the
advanced examples section of the vignette.</p>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-ameen1985discount" class="csl-entry">
Ameen, J. R. M., and Harrison, P. J. (1985). Discount bayesian
multiprocess modelling with cusums. In O. D. Anderson, editor, <em>Time
series analysis: Theory and practice 5</em>. North-Holland, Amsterdam.
</div>
<div id="ref-ArtigoMultivar" class="csl-entry">
dos Santos, S. V., Junior, Alves, M. B., and Migon, H. S. (2024). An
efficient sequential approach for joint modelling of multiple time
series.
</div>
<div id="ref-Kalman_filter_origins" class="csl-entry">
Kalman, R. E. (1960). A new approach to linear filtering and prediction
problems. <em>Transactions of the ASME–Journal of Basic
Engineering</em>, <em>82</em>(Series D), 35–45.
</div>
<div id="ref-AlexMP" class="csl-entry">
Schmidt, A. M., Freitas, L. P., Cruz, O. G., and Carvalho, M. S. (2022).
<a href="https://doi.org/10.1177/09622802221102628" class="external-link">A
poisson-multinomial spatial model for simultaneous outbreaks with
application to arboviral diseases</a>. <em>Statistical Methods in
Medical Research</em>, <em>31</em>(8), 1590–1602.
</div>
<div id="ref-WestHarr-DLM" class="csl-entry">
West, M., and Harrison, J. (1997). <em>Bayesian forecasting and dynamic
models (springer series in statistics)</em>. Hardcover; Springer-Verlag.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Silvaneo dos Santos Jr., Mariane Branco Alves, Hélio dos Santos Migon.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
