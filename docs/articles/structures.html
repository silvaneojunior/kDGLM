<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Creation of model structures • kDGLM</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Creation of model structures">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">kDGLM</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.2.8</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/intro.html">Introduction</a></li>
    <li><a class="dropdown-item" href="../articles/structures.html">Creation of model structures</a></li>
    <li><a class="dropdown-item" href="../articles/outcomes.html">Creation of model outcomes</a></li>
    <li><a class="dropdown-item" href="../articles/fitting.html">Fitting and analysing models</a></li>
    <li><a class="dropdown-item" href="../articles/example1.html">Space-time model hospital admissions from gastroenteritis</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/silvaneojunior/kDGLM/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Creation of model structures</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/silvaneojunior/kDGLM/blob/HEAD/vignettes/structures.Rmd" class="external-link"><code>vignettes/structures.Rmd</code></a></small>
      <div class="d-none name"><code>structures.Rmd</code></div>
    </div>

    
    
<style>
body {
text-align: justify}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script><div class="section level2">
<h2 id="table-of-contents">Table of contents<a class="anchor" aria-label="anchor" href="#table-of-contents"></a>
</h2>
<ol>
<li>
<details><summary><a href="intro.html">Introduction:</a> &gt;
</summary><ul>
<li>
<a href="intro.html#introduction">Introduction</a>
</li>
<li>
<a href="intro.html#notation">Notation</a>
</li>
</ul></details>
</li>
<li>
<details><summary><a href="structures.html">Creating the model structure:</a> &gt;
</summary><ul>
<li>
<a href="structures.html#a-structure-for-polynomial-trend-models">A
structure for polynomial trend models</a>
</li>
<li>
<a href="structures.html#a-structure-for-dynamic-regression-models">A
structure for dynamic regression models</a>
</li>
<li>
<a href="structures.html#a-structure-for-harmonic-trend-models">A
structure for harmonic trend models</a>
</li>
<li>
<a href="structures.html#a-structure-for-autoregresive-models">A
structure for autoregresive models</a>
</li>
<li>
<a href="structures.html#a-structure-for-overdispersed-models">A
structure for overdispersed models</a>
</li>
<li>
<a href="structures.html#handling-multiple-structural-blocks">Handling
multiple structural blocks</a>
</li>
<li>
<a href="structures.html#handling-multiple-linear-predictors">Handling
multiple linear predictors</a>
</li>
<li>
<a href="structures.html#handling-unknown-components-in-the-planning-matrix-f_t">Handling
unknown components in the planning matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math></a>
</li>
<li>
<a href="structures.html#special-priors">Special priors</a>
</li>
</ul></details>
</li>
<li>
<details><summary><a href="outcomes.html">Creating the model outcome:</a> &gt;
</summary><ul>
<li>
<a href="outcomes.html#normal-case">Normal case</a>
</li>
<li>
<a href="outcomes.html#poisson-case">Poisson case</a>
</li>
<li>
<a href="outcomes.html#gamma-case">Gamma case</a>
</li>
<li>
<a href="outcomes.html#multinomial-case">Multinomial case</a>
</li>
<li>
<a href="outcomes.html#handling-multiple-outcomes">Handling multiple
outcomes</a>
</li>
</ul></details>
</li>
<li>
<details><summary><a href="fitting.html">Fitting and analysing models:</a> &gt;
</summary><ul>
<li>
<a href="fitting.html#filtering-and-smoothing">Filtering and
smoothing</a>
</li>
<li>
<a href="fitting.html#extracting-components">Extracting components</a>
</li>
<li>
<a href="fitting.html#forecasting">Forecasting</a>
</li>
<li>
<a href="fitting.html#intervention-and-monitoring">Intervention and
monitoring</a>
</li>
<li>
<a href="fitting.html#tools-for-sensibility-analysis">Tools for
sensibility analysis</a>
</li>
<li>
<a href="fitting.html#sampling-and-hyper-parameter-estimation">Sampling
and hyper parameter estimation</a>
</li>
</ul></details>
</li>
<li>
<details><summary>
Advanced examples:&gt;
</summary><ul><li>
<a href="example1.html">Space-time model hospital admissions from
gastroenteritis</a>
</li></ul></details>
</li>
</ol>
</div>
<div class="section level2">
<h2 id="creation-of-model-structures">Creation of model structures<a class="anchor" aria-label="anchor" href="#creation-of-model-structures"></a>
</h2>
<p>In this section we will discuss the specification of the model
structure. We will consider the structure of a model as all the elements
that determine the relation between our linear predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>λ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\lambda}_t</annotation></semantics></math>
and our latent states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\theta}_t</annotation></semantics></math>
though time. Thus, the present section is dedicated to the definition of
the following, highlighted equations from a general dynamic generalized
model:</p>
<p><span class="math display">$$
\require{color}
\begin{equation}
\begin{aligned}
Y_t|\eta_t &amp;\sim \mathcal{F}\left(\eta_t\right),\\
g(\eta_t) &amp;= {\color{red}\lambda_{t}=F_t'\theta_t,}\\
{\color{red}\theta_t }&amp;{\color{red}=G_t\theta_{t-1}+\omega_t,}\\
{\color{red}\omega_t }&amp;{\color{red}\sim \mathcal{N}_n(h_t,W_t)}.
\end{aligned}
\end{equation}
$$</span></p>
<p>Namely, we consider that the structure of a model consists of the
matrices/vectors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>t</mi></msub><annotation encoding="application/x-tex">G_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>h</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{h}_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mi>t</mi></msub><annotation encoding="application/x-tex">H_t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mi>t</mi></msub><annotation encoding="application/x-tex">D_t</annotation></semantics></math>.</p>
<p>Although we allow the user to manually define each entry of each of
those matrices (which we <strong>do not</strong> recommend), we also
offer tools to simplify this task. Currently, we offer support for the
following base structures:</p>
<ul>
<li>
<code>polynomial_block</code>: Structural block for polynomial
trends <span class="citation">(see <a href="#ref-WestHarr-DLM">West and
Harrison, 1997, Chapter 7</a>)</span>. As special cases, this block has
support for random walks and linear growth models.</li>
<li>
<code>harmonic_block</code>: Structural block for seasonal trends
using harmonics <span class="citation">(see <a href="#ref-WestHarr-DLM">West and Harrison, 1997, Chapter
8</a>)</span>.</li>
<li>
<code>regression_block</code>: Structural block for (dynamic)
regressions <span class="citation">(see <a href="#ref-WestHarr-DLM">West
and Harrison, 1997, Chapter 6</a> and 9)</span>.</li>
<li>
<code>TF_block</code>: Structural block for autoregressive
components and transfer functions <span class="citation">(see <a href="#ref-WestHarr-DLM">West and Harrison, 1997, Chapter 9</a> and
13)</span>.</li>
<li>
<code>noise_block</code>: Structural block for random effects <span class="citation">dos Santos et al. (<a href="#ref-ArtigoMultivar">2024</a>)</span>.</li>
</ul>
<p>For the sake of brevity, we will present only the details for the
<code>polynomial_block</code>, since all other functions have very
similar usage (the full description of each block can be found in the
vignette, in the reference manual and in their respective help
pages).</p>
<p>Along with the aforementioned functions, we also present some
auxiliary functions and operations to help the user manipulate created
structural blocks.</p>
<p>In Subsections <a href="structures.html#a-structure-for-polynomial-trend-models">A
structure for polynomial trend models</a>, <a href="structures.html#a-structure-for-dynamic-regression-models">A
structure for dynamic regression models</a>, <a href="structures.html#a-structure-for-harmonic-trend-models">A structure
for harmonic trend models</a>, <a href="structures.html#a-structure-for-autoregresive-models">A structure
for autoregresive models</a> and <a href="structures.html#a-structure-for-overdispersed-models">A structure
for overdispersed models</a> introduce the several functions design to
facilitate the creation of single structural blocks. In those sections
we begin by examining simplistic models, characterized by a single
structural block and one linear predictor, with a completely known
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
matrix. Subsection <a href="structures.html#handling-multiple-structural-blocks">Handling
multiple structural blocks</a> builds upon these concepts, exploring
models that incorporate multiple structural blocks while maintaining a
singular linear predictor. The focus shifts in Subsection <a href="structures.html#handling-multiple-linear-predictors">Handling
multiple linear predictors</a>, where we delve into the specification of
multiple linear predictors within the same model. In Section <a href="structures.html#handling-unknown-components-in-the-planning-matrix-f_t">Handling
unknown components in the planning matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math></a>,
the discussion turns to scenarios where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
includes one or more unknown components. Finally, Subsection <a href="structures.html#special-priors">Special priors</a> provides a
brief examination of functions used to define specialized priors.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-polynomial-trend-models">A structure for polynomial trend models<a class="anchor" aria-label="anchor" href="#a-structure-for-polynomial-trend-models"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span><span class="va">...</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>, name <span class="op">=</span> <span class="st">"Var.Poly"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">1</span>, h <span class="op">=</span> <span class="fl">0</span>, H <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>, R1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">9</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># When used in a formula</span></span>
<span><span class="fu"><a href="../reference/polynomial_block.html">pol</a></span><span class="op">(</span>order <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span>, a1 <span class="op">=</span> <span class="fl">0</span>, R1 <span class="op">=</span> <span class="fl">9</span>, name <span class="op">=</span> <span class="st">"Var.Poly"</span><span class="op">)</span></span></code></pre></div>
<p>Recall the notation introduced in Section <a href="intro.html#notation">Notation</a> and revisited at the beginning
of this vignette. The <code>polynomial_block</code> function will create
a structural block based on <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 7. The
<code>pol</code> function is a simplified version meant to be used
inside formulas in the <code>kdglm</code> function and has the same
syntax as the <code>polynomial_block</code> function. This involves the
creation of a latent vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>θ</mi><mrow><mi>n</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\vec{\theta}_t=(\theta_{1,t},...,\theta_{n,t})'</annotation></semantics></math>,
such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>θ</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ω</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>n</mi><mo>−</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mrow><mi>n</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mrow><mi>n</mi><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ω</mi><mrow><mi>n</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mn>1</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ω</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>ω</mi><mrow><mi>n</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>h</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo>,</mo><msub><mi>W</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}
\begin{aligned}
\theta_{i,t} &amp;= \theta_{i,t-1}+\theta_{i+1, t-1}+\omega_{i,t}, i=1,...,n-1\\
\theta_{n,t} &amp;= \theta_{n,t-1}+\omega_{n,t},\\
\theta_1&amp;\sim \mathcal{N}_k(a_1,R_1),\\
\omega_{1,t},...,\omega_{n,t}&amp;\sim \mathcal{N}_n(\vec{h}_t,W_t),
\end{aligned}
\label{eq:defpol}
\end{equation}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>t</mi></msub><mo>=</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>θ</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>𝒟</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>⊙</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>D</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊘</mo><msub><mi>D</mi><mi>t</mi></msub><mo>+</mo><msub><mi>H</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">W_t=Var[\theta_t|\mathcal{D}_{t-1}]\odot (1-D_t) \oslash D_t+H_t</annotation></semantics></math>.</p>
<p>Let’s dissect each component of this specification.</p>
<p>The <code>order</code> argument sets the polynomial block’s order,
correlating
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
with the value passed.</p>
<p>The optional <code>name</code> argument aids in identifying each
structural block in post-fitting analysis, such as plotting or result
examination (see Section <a href="fitting.html">Fitting and analysing
models</a>).</p>
<p>The <code>D</code>, <code>h</code>, <code>H</code>, <code>a1</code>,
and <code>R1</code> arguments correspond to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mi>t</mi></msub><annotation encoding="application/x-tex">D_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>h</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{h}_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mi>t</mi></msub><annotation encoding="application/x-tex">H_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>a</mi><mo accent="true">→</mo></mover><mn>1</mn></msub><annotation encoding="application/x-tex">\vec{a}_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>R</mi><mn>1</mn></msub><annotation encoding="application/x-tex">R_1</annotation></semantics></math>,
respectively.</p>
<p><code>D</code> specifies the discount matrices over time. Its format
varies: a scalar implies a constant discount factor; a vector of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
(the length of the time series) means varying discount factors over
time; a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\times n</annotation></semantics></math>
matrix indicates that the same discount matrix is given by
<code>D</code> and is the same for all times; a 3D-array of dimension
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi><mo>×</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">n\times n\times T</annotation></semantics></math>
indicates time-specific discount matrices. Any other shape for
<code>D</code> is considered invalid.</p>
<p><code>h</code> specifies the drift vector over time. If
<code>h</code> is a scalar, it is understood that the drift is the same
for all variables at all time. If <code>h</code> is a vector of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>,
then it is understood that the drift is the same for all variables, but
have different values for each time, such that each coordinate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
of <code>h</code> represents the drift for time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
If <code>h</code> is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">n \times T</annotation></semantics></math>
matrix, then we assume that the drift vector at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is given by <code>h[,t]</code>. Any other shape for <code>h</code> is
considered invalid.</p>
<p>The argument <code>H</code> follows the same syntax as
<code>D</code>, since the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mi>t</mi></msub><annotation encoding="application/x-tex">H_t</annotation></semantics></math>
has the same shape as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>D</mi><mi>t</mi></msub><annotation encoding="application/x-tex">D_t</annotation></semantics></math>.</p>
<p>The argument <code>a1</code> and <code>R1</code> are used to define,
respectively the mean and the covariance matrix for the prior for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math>.
If <code>a1</code> is a scalar, it is understood that all latent states
associated with this block have the same prior mean; if <code>a1</code>
is a vector of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
then it is understood that the prior mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>1</mn></msub><annotation encoding="application/x-tex">a_1</annotation></semantics></math>
is given by <code>a1</code>. If <code>R1</code> is a scalar, it is
understood that the latent states have independent priors with the same
variance (this does not imply that they will have independent
posteriors); if <code>R1</code> is a vector of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
it is understood that the latent states have independent priors and that
the prior variance for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\theta_{i,1}</annotation></semantics></math>
is given by <code>R1[i]</code>; if <code>R1</code> is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math>
matrix, it is understood that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>R</mi><mn>1</mn></msub><annotation encoding="application/x-tex">R_1</annotation></semantics></math>
is given by <code>R1</code>. Any other shape for <code>a1</code> or
<code>R1</code> are considered invalid.</p>
<p>The arguments <code>D</code>, <code>h</code>, <code>H</code>,
<code>a1</code>, and <code>R1</code> can accept character values,
indicating that certain parameters are not fully defined. In such cases,
the dimensions of these arguments are interpreted in the same manner as
their numerical counterparts. For instance, if <code>D</code> is a
single character, it implies a uniform, yet unspecified, discount factor
across all variables and time points, with <code>D</code> serving as a
placeholder label. Should <code>D</code> be a vector of length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
(the time series length), it suggests varying discount factors over
time, with each character entry in the vector (e.g., <code>D[i]</code>)
acting as a label for the discount factor at the respective time point.
This logic extends to the other arguments and their various dimensional
forms. It’s crucial to recognize that if these arguments are specified
as labels rather than explicit values, the corresponding model block is
treated as “undefined,” indicating the absence of a key hyperparameter.
Consequently, a model with an undefined block cannot be fitted. Users
must either employ the <code>specify.dlm_block</code> method to replace
labels with concrete values or pass the value of the value of those
hyper-parameter as named values to the <code>fit_model</code> function
to systematically evaluate models with different values for these
labels. Section <a href="fitting.html#tools-for-sensitivity-analysis">Tools for sensitivity
analysis</a> elaborates on the available tools for sensitivity analysis.
Further information about both <code>specify</code> and
<code>fit_model</code> is available in the reference manual or through
the <code>help</code> function.</p>
<p>Notice that the user does not need to specify the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>t</mi></msub><annotation encoding="application/x-tex">G_t</annotation></semantics></math>,
since it is implicitly determined by the equation and the order of the
polynomial block. Each type of block will define it own matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>t</mi></msub><annotation encoding="application/x-tex">G_t</annotation></semantics></math>,
as such, the user does not need to worry about
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>t</mi></msub><annotation encoding="application/x-tex">G_t</annotation></semantics></math>,
except in very specific circumstances, where an advanced user may need a
type of model that is not yet implemented.</p>
<p>The argument <code>...</code> is used to specify the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
(see details in Subsection <a href="structures.html#handling-multiple-linear-predictors">Handling
multiple linear predictors</a>). Specifically, the user must provide a
list of named values which are arbitrary labels to each linear predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\lambda_{i,t}</annotation></semantics></math>
,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,k</annotation></semantics></math>,
and its associated value represents the effect of the level
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\theta_{1,t}</annotation></semantics></math>
(see Eq. ) in this predictor.</p>
<p>For example, consider a polynomial block of order
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>,
representing a linear growth. If the user passes an extra argument
<code>lambda</code> (the naming is arbitrary) as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>,
then the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
is created as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
F_t=\begin{bmatrix}1\\0\end{bmatrix}
</annotation></semantics></math></p>
<p>Note that, as the polynomial block has order
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>,
it has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>
latent states,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\theta_{1,t}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\theta_{2,t}</annotation></semantics></math>.
While
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\theta_{2,t}</annotation></semantics></math>
does not affect the linear predictor <code>lambda</code> directly, it
serves as an auxiliary variable to induce a more complex dynamic for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\theta_{1,t}</annotation></semantics></math>.
Indeed, by Equation , we have that a second order polynomial block have
the following temporal evolution:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ω</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ω</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ω</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><msub><mi>ω</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>h</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><mo>,</mo><msub><mi>W</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\theta_{1,t} &amp;= \theta_{1,t-1}+\theta_{2, t-1}+\omega_{1,t}\\
\theta_{2,t} &amp;= \theta_{2,t-1}+\omega_{2,t},\\
\omega_{1,t},\omega_{2,t}&amp;\sim \mathcal{N}_2(\vec{h}_t,W_t).
\end{aligned}
</annotation></semantics></math></p>
<p>As such,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\theta_{2,t}</annotation></semantics></math>
represents a growth factor that is added in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\theta_{1,t}</annotation></semantics></math>
and smoothly changes overtime. Even more complex structures can be
defined, either by a higher order polynomial block or by one of the
several other types of block offered by the
<em><code>kDGLM</code></em>.</p>
<p>The specification of values associated to each predictor label is
further illustrated in the examples further exhibited in this
section.</p>
<p>Lastly, the argument <code>monitoring</code> shall be explained
later, in Subsection <a href="fitting.html#intervention-and-monitoring">Intervention and
monitoring</a>, which discusses automated monitoring and
interventions.</p>
<p>To exemplify the usage of this function, let us assume that we have a
simple Normal model with known variance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>σ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math>,
in which
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
is the mean parameter and the link function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>
is such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>η</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>η</mi></mrow><annotation encoding="application/x-tex">g(\eta)=\eta</annotation></semantics></math>.
Let us also assume that the mean is constant over time and we have no
explanatory variables, so that our model can be simply written as:</p>
<p><span class="math display">$$
\begin{aligned}
Y_t|\theta_t &amp;\sim \mathcal{N}_1\left(\eta_t, \sigma^2\right),\\
\eta_t &amp;={\color{red}\lambda_{t}=\theta_t,}\\
{\color{red}\theta_t} &amp;{\color{red}=\theta_{t-1}=\theta.}
\end{aligned}
$$</span></p>
<p>In this case, we have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F_t=1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">G_t=1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">D_t=1</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>t</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h_t=0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>t</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H_t=0</annotation></semantics></math>,
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
Assuming a prior distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>9</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{N}(0,9)</annotation></semantics></math>
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>,
we can create the highlighted structure using the following code:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span>, name <span class="op">=</span> <span class="st">"Mean"</span><span class="op">)</span></span></code></pre></div>
<p>Setting <code>eta=1</code>, we specify that there is a linear
predictor named <em>eta</em>, and that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>t</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>×</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">eta = 1 \times \theta</annotation></semantics></math>.
Setting <code>order = 1</code>, we specify that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_t</annotation></semantics></math>
is a scalar and that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">G_t=1</annotation></semantics></math>.
We can omit the values of <code>a1</code> , <code>R1</code>,
<code>D</code>, <code>h</code> and <code>H</code>, since the default
values reflect the specified model. We could also omit the argument
<code>order</code>, since the default is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>,
but we chose to explicit define it so as to emphasize its usage. The
argument <code>name</code> specifies a label for the created block; in
this case, we chose to call it “Mean”, to help identify its role in our
model.</p>
<p>Suppose now that we have an explanatory variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
that we would like to introduce in our model to help explain the
behavior of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\eta_t</annotation></semantics></math>.
We could similarly define such structure by creating an additional block
such as:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="va">X</span>, name <span class="op">=</span> <span class="st">"Var X"</span><span class="op">)</span></span></code></pre></div>
<p>By setting <code>eta=X</code>, we specify that there is a linear
predictor called <em>eta</em>, and that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>t</mi><mi>a</mi><mo>=</mo><mi>X</mi><mo>×</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">eta = X \times \theta</annotation></semantics></math>.
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>X</mi><mi>T</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">X=(X_1,...,X_T)'</annotation></semantics></math>
is a vector, then we would have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>t</mi></msub><mo>=</mo><msub><mi>X</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">F_t=X_t</annotation></semantics></math>,
for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>t</mi><msub><mi>a</mi><mi>t</mi></msub><mo>=</mo><msub><mi>X</mi><mi>t</mi></msub><mo>×</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">eta_t = X_t \times \theta</annotation></semantics></math>.</p>
<p>It should be noted that <code>kDGLM</code> has a specific structural
block designed for regressions, <code>regression_block</code>, but we
also allow any structural block to be used for a regression, by just
setting the value assigned to the predictor equal to the regressor
vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>X</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">X_t, t=1, \ldots, X_T</annotation></semantics></math>.</p>
<p>The user can specify complex temporal dynamics for the effects of any
co-variate. For instance, it could be assumed that a regressor has a
seasonal effect on a linear predictor. This this could be accommodated
by the insertion of the values of the regressor associated to a seasonal
block. The use of seasonal blocks is illustrated in Section <a href="example1.html">Space-time model hospital admissions from
gastroenteritis</a>.</p>
<p>So far, we have only discussed the creation of static latent effects,
but the inclusion of stochastic temporal dynamics is very
straightforward. One must simply specify the values of <code>H</code> to
be greater than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
and/or the values of <code>D</code> to be lesser than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span>, name <span class="op">=</span> <span class="st">"Mean"</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span></code></pre></div>
<p>Notice that a dynamic regression model could be obtained by assigning
<code>eta=X</code> in the previous code line. Bellow we present a plot
of two simple trend models fitted to the same data: one with a static
mean and another using a dynamic mean.</p>
<p>In the following example we use the functions <code>Normal</code>,
<code>fit_model</code> and the <code>plot</code> method. We advise the
reader to initially concentrate solely on the application of the
<code>polynomial_block</code>. The functionalities and detailed usage of
the other functions and methods, <code>Normal</code>,
<code>fit_model</code>, and <code>plot</code>, will be explored in later
sections, specifically in Sections <a href="outcomes.html">Creating the
model outcome:</a> and <a href="fitting.html">Fitting and analysing
models:</a>. The inclusion of these functions in the current example is
primarily to offer a comprehensive and operational code sample.</p>
<p><img src="structures_files/figure-html/unnamed-chunk-6-1.png" width="672"></p>
<p>For an extensive presentation and thorough discussion of the
theoretical aspects underlying the structure highlighted in this
section, interested readers are encouraged to consult <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, Chapters 6, 7, and 9.
Additionally, we strongly recommend that all users refer to the
associated documentation for more detailed information. This can be
accessed by using the <code><a href="../reference/polynomial_block.html">help(polynomial_block)</a></code> function or
consulting the reference manual.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-dynamic-regression-models">A structure for dynamic regression models<a class="anchor" aria-label="anchor" href="#a-structure-for-dynamic-regression-models"></a>
</h2>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span><span class="va">...</span>,</span>
<span>  max.lag <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  zero.fill <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var.Reg"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1 <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">max.lag</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># When used in a formula</span></span>
<span><span class="fu"><a href="../reference/regression_block.html">reg</a></span><span class="op">(</span><span class="va">X</span>, max.lag <span class="op">=</span> <span class="fl">0</span>, zero.fill <span class="op">=</span> <span class="cn">TRUE</span>, D <span class="op">=</span> <span class="fl">0.95</span>, a1 <span class="op">=</span> <span class="fl">0</span>, R1 <span class="op">=</span> <span class="fl">9</span>, name <span class="op">=</span> <span class="st">"Var.Reg"</span><span class="op">)</span></span></code></pre></div>
<p>The <code>regression_block</code> function creates a structural block
for a dynamic regression with covariate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>t</mi></msub><annotation encoding="application/x-tex">X_t</annotation></semantics></math>,
as specified in <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 9. The
<code>reg</code> function is a simplified version meant to be used
inside formulas in the <code>kdglm</code> function and has the same
syntax as the <code>regression_block</code> function. When
<code>max.lag</code> is equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>,
this function can be see as a wrapper for the
<code>polynomial_block</code> function with order equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>.
When <code>max.lag</code> is greater or equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>,
the <code>regression_block</code> function is equivalent to the
superposition of several <code>polynomial_block</code> functions with
order equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>.
Specifically, if the linear predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\lambda_t</annotation></semantics></math>
is associated with this block, we can describe its structure with the
following equations:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>.</mi><mi>l</mi><mi>a</mi><mi>g</mi></mrow></munderover><msub><mi>X</mi><mrow><mi>t</mi><mo>−</mo><mi>i</mi></mrow></msub><msub><mi>θ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ω</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mspace width="1.0em"></mspace><mo>∀</mo><mi>i</mi><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ω</mi><mrow><mn>0</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>ω</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>.</mi><mi>l</mi><mi>a</mi><mi>g</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>.</mi><mi>l</mi><mi>a</mi><mi>g</mi><mo>+</mo><mn>1</mn></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>W</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>θ</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>.</mi><mi>l</mi><mi>a</mi><mi>g</mi><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>.</mi><mi>l</mi><mi>a</mi><mi>g</mi><mo>+</mo><mn>1</mn></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
\lambda_t&amp;=\sum_{i=0}^{max.lag}X_{t-i}\theta_{i,t},\\
\theta_{i,t}&amp;=\theta_{i,t-1}+\omega_{i,t},\quad \forall i,\\
\omega_{0,t},...,\omega_{max.lag,t}&amp;\sim \mathcal{N}_{max.lag+1}(0,W_t),\\
\theta_{0,1},...,
\theta_{max.lag,1}&amp;\sim \mathcal{N}_{max.lag+1}(a_1,R_1),
\end{aligned}
\end{equation}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>t</mi></msub><mo>=</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>θ</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>𝒟</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>⊙</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>D</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊘</mo><msub><mi>D</mi><mi>t</mi></msub><mo>+</mo><msub><mi>H</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">W_t=Var[\theta_t|\mathcal{D}_{t-1}]\odot (1-D_t) \oslash D_t+H_t</annotation></semantics></math>.</p>
<p>The usage of the <code>regression_block</code> function is quite
similar to that of the <code>polynomial_block</code> function, the only
differences being in the <code>max.lag</code> and <code>zero.fill</code>
arguments. The <code>max.lag</code> defines the maximum lag of the
variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>t</mi></msub><annotation encoding="application/x-tex">X_t</annotation></semantics></math>
that has effect on the linear predictor. For example, if we define
<code>max.lag</code> as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>,
we would be defining that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>t</mi></msub><annotation encoding="application/x-tex">X_t</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">X_{t-1}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>t</mi><mo>−</mo><mn>2</mn></mrow></msub><annotation encoding="application/x-tex">X_{t-2}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>t</mi><mo>−</mo><mn>3</mn></mrow></msub><annotation encoding="application/x-tex">X_{t-3}</annotation></semantics></math>
all have an effect on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\lambda_t</annotation></semantics></math>,
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>.</mi><mi>l</mi><mi>a</mi><mi>g</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">max.lag+1</annotation></semantics></math>
latent variables are created, each one representing the effect of a
lagged value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>t</mi></msub><annotation encoding="application/x-tex">X_t</annotation></semantics></math>.</p>
<p>Lastly, the <code>zero.fill</code> argument defines if the package
should take the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>t</mi></msub><annotation encoding="application/x-tex">X_t</annotation></semantics></math>
to be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is non-positive, i.e., if <code>TRUE</code> (default), the package
considers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">X_t=0</annotation></semantics></math>,
for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn><mo>,</mo><mi>−</mi><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>−</mi><mi>m</mi><mi>a</mi><mi>x</mi><mi>.</mi><mi>l</mi><mi>a</mi><mi>g</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t=0,-1,...,-max.lag+1</annotation></semantics></math>.
If <code>zero.fill</code> is <code>FALSE</code>, then the user must
provide the values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>t</mi></msub><annotation encoding="application/x-tex">X_t</annotation></semantics></math>
as a vector of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>+</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>.</mi><mi>l</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">T+max.lag</annotation></semantics></math>
(instead of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>),
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
is the length of the time series that is being modeled, and the first
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>.</mi><mi>l</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">max.lag</annotation></semantics></math>
values of that vector will be taken as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mrow><mi>−</mi><mi>m</mi><mi>a</mi><mi>x</mi><mi>.</mi><mi>l</mi><mi>a</mi><mi>g</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>X</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">X_{-max.lag+1},...,X_0</annotation></semantics></math>.</p>
<p>The usage of the remaining arguments is identical to that of the
<code>polynomial_block</code> function, and can also be inferred by the
previous equation.</p>
<p>Here we present the code for fitting the following model:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>θ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mi>t</mi></msub><mo>=</mo><msub><mi>X</mi><mi>t</mi></msub><msub><mi>θ</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ω</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ω</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>W</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
Y_t|\theta_t &amp;\sim Poisson\left(\eta_t\right),\\
\ln(\eta_t) &amp;=\lambda_{t}=X_t\theta_t,\\
\theta_t&amp;=\theta_{t-1}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t),
\end{aligned}
\end{equation}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>t</mi></msub><annotation encoding="application/x-tex">X_t</annotation></semantics></math>
is a known covariate and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>W</mi><mi>t</mi></msub><annotation encoding="application/x-tex">W_t</annotation></semantics></math>
is specified using a discount factor of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.95</mn><annotation encoding="application/x-tex">0.95</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">regression</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span>The_name_of_the_linear_predictor <span class="op">=</span> <span class="va">X</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span></span>
<span><span class="va">outcome</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"The_name_of_the_linear_predictor"</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">regression</span>, <span class="va">outcome</span><span class="op">)</span></span></code></pre></div>
<p><img src="structures_files/figure-html/unnamed-chunk-10-1.png" width="672"></p>
<p>The detailed theory behind the structure discussed in this section
can be found in chapters 6 and 9 from <span class="citation">West and
Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-harmonic-trend-models">A structure for harmonic trend models<a class="anchor" aria-label="anchor" href="#a-structure-for-harmonic-trend-models"></a>
</h2>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span></span>
<span>  <span class="va">...</span>,</span>
<span>  <span class="va">period</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var.Sazo"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1 <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">order</span> <span class="op">*</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># When used in a formula</span></span>
<span><span class="fu"><a href="../reference/harmonic_block.html">har</a></span><span class="op">(</span><span class="va">period</span>, order <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.98</span>, a1 <span class="op">=</span> <span class="fl">0</span>, R1 <span class="op">=</span> <span class="fl">4</span>, name <span class="op">=</span> <span class="st">"Var.Sazo"</span><span class="op">)</span></span></code></pre></div>
<p>This function will creates a structural block based on <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 8, i.e., it creates a
latent vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>×</mo><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>×</mo><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\theta_t=(\theta_{1,t},\theta_{2,t},...,\theta_{2\times order-1,t},\theta_{2\times order,t})'</annotation></semantics></math>,
so that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>θ</mi><mrow><mn>2</mn><mi>i</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>θ</mi><mrow><mn>2</mn><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>c</mi><mi>o</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>w</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>w</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>−</mi><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>w</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mi>c</mi><mi>o</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mi>w</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>θ</mi><mrow><mn>2</mn><mi>i</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>θ</mi><mrow><mn>2</mn><mi>i</mi><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>ω</mi><mrow><mn>2</mn><mi>i</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>ω</mi><mrow><mn>2</mn><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>×</mo><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mrow><mn>2</mn><mo>×</mo><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ω</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>ω</mi><mrow><mn>2</mn><mo>×</mo><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mrow><mn>2</mn><mo>×</mo><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>W</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
\begin{bmatrix}\theta_{2i -1,t}\\ \theta_{2i,t}\end{bmatrix} = \begin{bmatrix}cos(iw) &amp; sin(iw)\\ -sin(iw) &amp; cos(iw)\end{bmatrix}&amp;\begin{bmatrix}\theta_{2i -1,t-1}\\ \theta_{2i,t-1}\end{bmatrix}+\begin{bmatrix}\omega_{2i -1,t}\\ \omega_{2i,t}\end{bmatrix}, i=1,...,order\\
\theta_{1,1},...,\theta_{2 \times order,1}&amp;\sim \mathcal{N}_{2\times order}(a_1,R_1),\\
\omega_{1,t},...,\omega_{2 \times order,t}&amp;\sim \mathcal{N}_{2\times order}(0,W_t),\\
\end{aligned}
\end{equation}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>t</mi></msub><mo>=</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>θ</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>𝒟</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>⊙</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>D</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊘</mo><msub><mi>D</mi><mi>t</mi></msub><mo>+</mo><msub><mi>H</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">W_t=Var[\theta_t|\mathcal{D}_{t-1}]\odot (1-D_t) \oslash D_t+H_t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mrow><mi>p</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">w=\frac{2\pi}{period}</annotation></semantics></math>.</p>
<p>Notice that the user does not need to specify the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>t</mi></msub><annotation encoding="application/x-tex">G_t</annotation></semantics></math>,
since it is implicitly determined by the order and the period of the
harmonic block, being a block diagonal matrix where each block is a
rotation matrix for an angle multiple of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math>,
such that, if <code>period</code> is an integer,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>G</mi><mi>t</mi><mrow><mi>p</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>d</mi></mrow></msubsup><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">G_t^{period}=I</annotation></semantics></math>.
Notice that, when <code>period</code> is an integer, it represents the
length of the seasonal cycle. For instance, if we have a time series
with monthly observations and we believe this series to have an annual
pattern, then we would set the <code>period</code> for the harmonic
block to be equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>12</mn><annotation encoding="application/x-tex">12</annotation></semantics></math>
(the number of observations until the cycle “resets”). For details about
the order of the harmonic block and the representation of seasonal
patterns with Fourier Series, see <span class="citation">West and
Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 8.</p>
<p>The natural usage of this block is for specifying harmonic trends for
the model, but it can also be used for explanatory variables with
seasonal effect on the linear predictor, for that, see the usage of the
<code>regression_block</code> and <code>polynomial_block</code>
functions.</p>
<p>Here we present a simply usage example for a harmonic block with
period
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>12</mn><annotation encoding="application/x-tex">12</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  period <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.975</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Bellow we present a plot of a Poisson model with such structure:</p>
<p><img src="structures_files/figure-html/unnamed-chunk-14-1.png" width="672"></p>
<p>The detailed theory behind the structure discussed in this section
can be found in chapters 6, 8 and 9 from <span class="citation">West and
Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-autoregresive-models">A structure for autoregresive models<a class="anchor" aria-label="anchor" href="#a-structure-for-autoregresive-models"></a>
</h2>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/tf_block.html">TF_block</a></span><span class="op">(</span></span>
<span>  <span class="va">...</span>,</span>
<span>  <span class="va">order</span>,</span>
<span>  noise.var <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  noise.disc <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var.AR"</span>,</span>
<span>  AR.support <span class="op">=</span> <span class="st">"free"</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1 <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  h <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  D.coef <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h.coef <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H.coef <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1.coef <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  R1.coef <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.25</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  monitoring.coef <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">order</span><span class="op">)</span>,</span>
<span>  a1.pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1.pulse <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  D.pulse <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h.pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H.pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  monitoring.pulse <span class="op">=</span> <span class="cn">NA</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># When used in a formula</span></span>
<span><span class="fu"><a href="../reference/tf_block.html">TF</a></span><span class="op">(</span><span class="va">X</span>, order <span class="op">=</span> <span class="fl">1</span>, noise.var <span class="op">=</span> <span class="cn">NULL</span>, noise.disc <span class="op">=</span> <span class="cn">NULL</span>, a1 <span class="op">=</span> <span class="fl">0</span>, R1 <span class="op">=</span> <span class="fl">9</span>, a1.coef <span class="op">=</span> <span class="cn">NULL</span>, R1.coef <span class="op">=</span> <span class="cn">NULL</span>, a1.pulse <span class="op">=</span> <span class="fl">0</span>, R1.pulse <span class="op">=</span> <span class="fl">4</span>, name <span class="op">=</span> <span class="st">"Var.AR"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Wrapper for the autoregressive structure</span></span>
<span><span class="fu"><a href="../reference/tf_block.html">AR</a></span><span class="op">(</span>order <span class="op">=</span> <span class="fl">1</span>, noise.var <span class="op">=</span> <span class="cn">NULL</span>, noise.disc <span class="op">=</span> <span class="cn">NULL</span>, a1 <span class="op">=</span> <span class="fl">0</span>, R1 <span class="op">=</span> <span class="fl">9</span>, a1.coef <span class="op">=</span> <span class="cn">NULL</span>, R1.coef <span class="op">=</span> <span class="cn">NULL</span>, name <span class="op">=</span> <span class="st">"Var.AR"</span><span class="op">)</span></span></code></pre></div>
<p>This function creates a structural block based on <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 9, i.e., it creates a
latent state vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_t</annotation></semantics></math>,
an autoregressive (AR) coefficient vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ϕ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>ϕ</mi><mrow><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\phi_t=(\phi_{1,t},...,\phi_{order, t})'</annotation></semantics></math>
and a pulse coefficient vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ρ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>ρ</mi><mrow><mi>l</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">\rho_t=(\rho_{1,t},...,\rho_{l,t})'</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>l</mi><annotation encoding="application/x-tex">l</annotation></semantics></math>
is the number of pulses (discussed later on) so that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>ϕ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><msub><mi>θ</mi><mrow><mi>t</mi><mo>−</mo><mi>i</mi></mrow></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>l</mi></munderover><msub><mi>ρ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><msub><mi>X</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>ω</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ϕ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>ϕ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msubsup><mi>ω</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow><mtext mathvariant="normal">coef</mtext></msubsup><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ρ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>ρ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msubsup><mi>ω</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></msubsup><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ω</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>h</mi><mi>t</mi></msub><mo>,</mo><msub><mi>W</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>ω</mi><mi>t</mi><mtext mathvariant="normal">coef</mtext></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>h</mi><mi>t</mi><mtext mathvariant="normal">coef</mtext></msubsup><mo>,</mo><msubsup><mi>W</mi><mi>t</mi><mtext mathvariant="normal">coef</mtext></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>ω</mi><mi>t</mi><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>h</mi><mi>t</mi><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></msubsup><mo>,</mo><msubsup><mi>W</mi><mi>t</mi><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mn>1</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ϕ</mi><mn>1</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mtext mathvariant="normal">coef</mtext></msubsup><mo>,</mo><msubsup><mi>R</mi><mn>1</mn><mtext mathvariant="normal">coef</mtext></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ρ</mi><mn>1</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></msubsup><mo>,</mo><msubsup><mi>R</mi><mn>1</mn><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
\theta_{t} &amp;= \sum_{i=1}^{k}\phi_{i,t}\theta_{t-i}+\sum_{i=1}^{l}\rho_{i,t}X_{i,t}+\omega_{t},\\
\phi_{i,t}&amp;=\phi_{i,t-1}+\omega^{\text{coef}}_{i,t},\\
\rho_{i,t}&amp;=\rho_{i,t-1}+\omega_{i,t}^{pulse},\\
\omega_{t}&amp;\sim \mathcal{N}_1(h_t,W_t),\\
\omega_{t}^{\text{coef}}&amp;\sim \mathcal{N}_k(h_t^{\text{coef}},W_t^{\text{coef}}),\\
\omega_{t}^{pulse}&amp;\sim \mathcal{N}_l(h_t^{pulse},W_t^{pulse}),\\
\theta_1&amp;\sim \mathcal{N}(a_1,R_1),\\
\phi_1&amp;\sim \mathcal{N}_k(a_1^{\text{coef}},R_1^{\text{coef}}),\\
\rho_1&amp;\sim \mathcal{N}_l(a_1^{pulse},R_1^{pulse}).
\end{aligned}
\end{equation}
</annotation></semantics></math> where:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>W</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>n</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>e</mi><mi>.</mi><mi>v</mi><mi>a</mi><mi>r</mi></mtd><mtd columnalign="right" style="text-align: right"><mi>+</mi></mtd><mtd columnalign="left" style="text-align: left"><mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>n</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>e</mi><mi>.</mi><mi>d</mi><mi>i</mi><mi>s</mi><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>n</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>e</mi><mi>.</mi><mi>d</mi><mi>i</mi><mi>s</mi><mi>c</mi></mrow></mfrac><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>θ</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>𝒟</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>W</mi><mi>t</mi><mtext mathvariant="normal">coef</mtext></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msubsup><mi>H</mi><mi>t</mi><mtext mathvariant="normal">coef</mtext></msubsup></mtd><mtd columnalign="right" style="text-align: right"><mi>+</mi></mtd><mtd columnalign="left" style="text-align: left"><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>ϕ</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>𝒟</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"><mi>⊙</mi></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msubsup><mi>D</mi><mi>t</mi><mtext mathvariant="normal">coef</mtext></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"><mi>⊘</mi></mtd><mtd columnalign="left" style="text-align: left"><msubsup><mi>D</mi><mi>t</mi><mtext mathvariant="normal">coef</mtext></msubsup><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>W</mi><mi>t</mi><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msubsup><mi>H</mi><mi>t</mi><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></msubsup></mtd><mtd columnalign="right" style="text-align: right"><mi>+</mi></mtd><mtd columnalign="left" style="text-align: left"><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>ρ</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>𝒟</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"><mi>⊙</mi></mtd><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msubsup><mi>D</mi><mi>t</mi><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"><mi>⊘</mi></mtd><mtd columnalign="left" style="text-align: left"><msubsup><mi>D</mi><mi>t</mi><mrow><mi>p</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow></msubsup><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
W_t&amp;=noise.var&amp;+&amp;\frac{(1-noise.disc)}{noise.disc}Var[\theta_t|\mathcal{D}_{t-1}] &amp; &amp;  &amp; &amp; ,\\
W_t^{\text{coef}}&amp;=H_t^{\text{coef}}&amp;+&amp;Var[\phi_t|\mathcal{D}_{t-1}] &amp;\odot&amp; (1-D_t^{\text{coef}}) &amp;\oslash&amp; D_t^{\text{coef}},\\ W^{pulse}_t&amp;=H_t^{pulse}&amp;+&amp;Var[\rho_t|\mathcal{D}_{t-1}] &amp;\odot&amp;(1-D_t^{pulse}) &amp;\oslash&amp;D_t^{pulse},
\end{aligned}
\end{equation}
</annotation></semantics></math> and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>,
called pulse matrix, is a known
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>×</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">T \times l</annotation></semantics></math>
matrix.</p>
<p>Notice that the user does not need to specify the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>t</mi></msub><annotation encoding="application/x-tex">G_t</annotation></semantics></math>,
since it is implicitly determined by the order of the Tranfer Function
(TF) block and the equations above, although, as the reader might have
noticed, that evolution will always be non-linear. Since the method used
to fit models in this package requires a linear evolution, we use the
approach described in <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 13, to linearize the
previous evolution equation. For more details about the usage of
autoregressive models and transfer functions in the context of DLM’s,
see <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 9.</p>
<p>It is easy to understand the meaning of most arguments of the
<code>TF_block</code> function based on the previous equations, but some
explanation is still needed for the <code>AR.support</code> argument,
plus the arguments related with the so called <em>pulse</em>. We do
advise all users to consult the associated documentation for more
details (see <code><a href="../reference/tf_block.html">help(TF_block)</a></code> or the reference manual).</p>
<p>The <code>AR.support</code> is a character string, either
<code>"constrained"</code> or <code>"free"</code>. If
<code>AR.support</code> is <code>"constrained"</code>, then the AR
coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
will be forced to be on the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(-1,1)</annotation></semantics></math>,
otherwise, the coefficients will be unrestricted. Beware that, under no
restriction on the coefficients, there is no guarantee that the
estimated coefficients will imply in a stationary process, furthermore,
if the order of the TF block is greater than 1, then the restriction
imposed when <code>AR.support</code> is equal to
<code>"constrained"</code> does <strong>NOT</strong> guarantee that the
process will be stationary, as such, the user is not allowed to use
constrained parameters when the order of the block is greater than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>.
To constrain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
to the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(-1,1)</annotation></semantics></math>,
we apply the inverse Fisher transformation, also known as the hyperbolic
tangent function.</p>
<p>The pulse matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
is informed through the argument <code>pulse</code>, with the dimension
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\rho_t</annotation></semantics></math>
being implied by the number of columns in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>.
It is important to notice that the package expects that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
will inform the pulse value for each time instance, interpreting each
column as a distinct pulse with an associated coordinate of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\rho_t</annotation></semantics></math>.</p>
<p>Note that when the pulse is absent,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><mn>0</mn><mo>,</mo><mo>∀</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">X_t=0, \forall t</annotation></semantics></math>,
the TF block is equivalent to a autoregressive block.</p>
<p>Finally, we can summarize the usage of the <code>TF_block</code>
function as follows:</p>
<ul>
<li>
<code>a1</code>, <code>R1</code> are the parameter for the prior for
the accumulated effects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>−</mo><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">(\theta_1,...,\theta_{1-order})'</annotation></semantics></math>;</li>
<li>
<code>noise.var</code>, <code>noise.disc</code> and <code>h</code>
define the mean and variance of random fluctuations of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_t</annotation></semantics></math>
through time;</li>
<li>
<code>a1.coef</code>, <code>R1.coef</code> are the parameter for the
prior for the coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>ϕ</mi><mrow><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\phi_1, ...,\phi_{order}</annotation></semantics></math>;</li>
<li>
<code>h.coef</code>, <code>H.coef</code> and <code>D.coef</code>
define the mean and variance of random fluctuations of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
through time;</li>
<li>
<code>a1.pulse</code>, <code>R1.pulse</code> are the parameter for
the prior for the pulse coefficient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\rho_1</annotation></semantics></math>;</li>
<li>
<code>h.pulse</code>, <code>H.pulse</code> and <code>D.pulse</code>
define the mean and variance of random fluctuations of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\rho_t</annotation></semantics></math>
through time;</li>
<li>
<code>pulse</code> is the pulse matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>;</li>
<li>
<code>AR.support</code> defines the support for the AR coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>.</li>
</ul>
<p>Bellow we present the code for a simply
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">AR(1)</annotation></semantics></math>
block with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>t</mi></msub><mo>=</mo><mn>0.1</mn><mo>,</mo><mo>∀</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">W_t=0.1, \forall t</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/tf_block.html">TF_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  noise.var <span class="op">=</span> <span class="fl">0.1</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Finally we present a plot of a Gamma model with known shape
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1.5</mn></mrow><annotation encoding="application/x-tex">\alpha=1.5</annotation></semantics></math>
and a AR structure for the mean fitted with simulated data. We will
refrain to show the code for fitting the model itself, since we will
discuss the tools for fitting in a section of its own.</p>
<pre><code>, , 1

     eta
[1,]   1</code></pre>
<p><img src="structures_files/figure-html/unnamed-chunk-17-1.png" width="672"></p>
<div class="section level3">
<h3 id="some-comments-about-autoregressive-models-in-the-normal-family">Some comments about autoregressive models in the Normal family<a class="anchor" aria-label="anchor" href="#some-comments-about-autoregressive-models-in-the-normal-family"></a>
</h3>
<p>The user may have notice that the autoregressive block described
above is a little different from what is most common in the literature.
Specifically, we do not assume that the observed data itself
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>)
follows an autoregressive evolution, but instead
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_t</annotation></semantics></math>
does. This approach is a generalization of the usual autoregressive
model, indeed, if we have that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>
follows an usual AR(k), such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>ϕ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><msub><mi>Y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ϵ</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ϵ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mi>t</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
Y_t&amp;=\sum_{i=1}^{k}\phi_{i,t}Y_{t-1}+\epsilon_t,\\
\epsilon_t &amp;\sim \mathcal{N}_1(0,\sigma_t^2),
\end{aligned}
\end{equation}
</annotation></semantics></math> then, this model can also be written
as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>η</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>η</mi><mi>t</mi></msub><mo>=</mo><msub><mi>θ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>ϕ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><msub><mi>θ</mi><mrow><mi>t</mi><mo>−</mo><mi>i</mi></mrow></msub><mo>+</mo><msub><mi>ω</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ω</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>W</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
Y_t|\eta_t&amp;\sim \mathcal{N}_1(\eta_t,0),\\
\eta_t=\theta_t&amp;=\sum_{i=1}^{k}\phi_{i,t}\theta_{t-i}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t),
\end{aligned}
\end{equation}
</annotation></semantics></math> such that this model can be described
using the <code>TF_block</code> function.</p>
<p>More generally, if we have that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>η</mi><mi>t</mi></msub><mo>∼</mo><mi>ℱ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y_t|\eta_t \sim \mathcal{F}(\eta_t)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℱ</mi><annotation encoding="application/x-tex">\mathcal{F}</annotation></semantics></math>
is a distribution family contained in the exponential family and indexed
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\eta_t</annotation></semantics></math>,
then we have that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>η</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>ℱ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>θ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>ϕ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><msub><mi>θ</mi><mrow><mi>t</mi><mo>−</mo><mi>i</mi></mrow></msub><mo>+</mo><msub><mi>ω</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ω</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>W</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
Y_t|\eta_t &amp;\sim \mathcal{F}(\eta_t),\\
g(\eta_t)=\theta_t&amp;=\sum_{i=1}^{k}\phi_{i,t}\theta_{t-i}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t).
\end{aligned}
\end{equation}
</annotation></semantics></math></p>
<p>It is important to note that there is some caveats about the first
specification (the usual one) and the more general one presented above.
As the reader will see further bellow, we offer, as a particular case,
the Normal distribution with both unknown mean and observational
variance, where we can specify predictive strucutre for
<strong>both</strong> the mean and the observational variance. In this
model, it does matter if the evolution error is associated with the
observation equation or the evolution equation (we cannot specify
predictive structure for former, but to the latter we can). For such
cases, we recommend the use of the <code>regression_block</code>
function instead of the <code>TF_block</code>.</p>
<p>Here we present an example of the specification of an AR(k) using the
<code>regression_block</code> function for a time series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>
of length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">Y</span><span class="op">[</span><span class="op">-</span><span class="cn">T</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  max.lag <span class="op">=</span> <span class="va">k</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>In the Advanced Examples section we will provide a wide range of
examples, including ones with the aforementioned structures. In
particular, we will present the code for some usual (yet different from
what we discussed) forms of AR, including the following model:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>μ</mi><mi>t</mi></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>ϕ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>μ</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ϵ</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ϵ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mi>t</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
Y_t&amp;=\mu_t+\sum_{i=1}^{k}\phi_{i,t}(Y_{t-1}-\mu_{t-1})+\epsilon_t,\\
\epsilon_t &amp;\sim \mathcal{N}_1(0,\sigma_t^2),
\end{aligned}
\end{equation}
</annotation></semantics></math></p>
</div>
</div>
<div class="section level2">
<h2 id="a-structure-for-overdispersed-models">A structure for overdispersed models<a class="anchor" aria-label="anchor" href="#a-structure-for-overdispersed-models"></a>
</h2>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/noise_block.html">noise_block</a></span><span class="op">(</span><span class="va">...</span>, name <span class="op">=</span> <span class="st">"Noise"</span>, D <span class="op">=</span> <span class="fl">0.99</span>, R1 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># When used in a formula</span></span>
<span><span class="fu"><a href="../reference/noise_block.html">noise</a></span><span class="op">(</span>name <span class="op">=</span> <span class="st">"Noise"</span>, D <span class="op">=</span> <span class="fl">0.99</span>, R1 <span class="op">=</span> <span class="fl">0.1</span>, H <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p>This function will creates a sequence of <strong>independent</strong>
latent variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϵ</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>ϵ</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\epsilon_1,...,\epsilon_t</annotation></semantics></math>
based on the discussions presented in <span class="citation">dos Santos
et al. (<a href="#ref-ArtigoMultivar">2024</a>)</span>, such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ϵ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mi>t</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>σ</mi><mi>t</mi><mn>2</mn></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mfrac><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><mi>t</mi></mfrac><msub><mi>D</mi><mi>t</mi></msub><msubsup><mi>σ</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>+</mo><mfrac><mn>1</mn><mi>t</mi></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>D</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msubsup><mi>ϵ</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo stretchy="false" form="prefix">|</mo><msub><mi>𝒟</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msubsup><mi>σ</mi><mn>1</mn><mn>2</mn></msubsup></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>R</mi><mn>1</mn></msub><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
\epsilon_{t} &amp;\sim \mathcal{N}(0,\sigma_t^2),\\
\sigma_t^2&amp;=\frac{t-1}{t}D_t\sigma_{t-1}^2+\frac{1}{t}(1-D_t)\mathbb{E}[\epsilon_{t-1}^2|\mathcal{D}_{t-1}],\\
\sigma_1^2&amp;=R_1.
\end{aligned}
\end{equation}
</annotation></semantics></math></p>
<p>Notice that the user do not need to specify the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>t</mi></msub><annotation encoding="application/x-tex">G_t</annotation></semantics></math>,
since it is implicitly determined by the equations above, such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>t</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">G_t=0</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.</p>
<p>It is easy to see the correspondence between most of the arguments of
the <code>noise_block</code> function and their respective meaning in
the block specification, while the remaining ones follow the same usage
seen in the previous block functions (see the
<code>polynomial_block</code> function).</p>
<p>As the user must have noticed, this block makes no sense on its own,
since it has barely any capability of learning patterns. But, we is
shown in the next subsection, structural blocks can be combined with
each other, such that the noise block would be only one of several other
structural blocks in a model.</p>
<p>To exemplify the utility of this structural block, let us assume we
want to model the following (simulated) time series of counts:</p>
<p><img src="structures_files/figure-html/unnamed-chunk-20-1.png" width="672"></p>
<p>Since the data is a counting, its natural to propose a Poisson model,
such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>θ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mi>t</mi></msub><mo>=</mo><msub><mi>θ</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>θ</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>ω</mi><mi>t</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ω</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><msub><mi>𝒩</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>W</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{equation}
\begin{aligned}
Y_t|\theta_t &amp;\sim Poisson\left(\eta_t\right),\\
\ln(\eta_t) &amp;=\lambda_{t}=\theta_t,\\
\theta_t&amp;=\theta_{t-1}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t),
\end{aligned}
\end{equation}
</annotation></semantics></math></p>
<p>Bellow we present that model fitted using the <code>kDGLM</code>
package:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">level</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  rate <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">3</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.95</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">level</span>,</span>
<span>  <span class="st">"Model 1"</span> <span class="op">=</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"rate"</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.data</span>, lag <span class="op">=</span> <span class="fl">1</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="structures_files/figure-html/unnamed-chunk-21-1.png" width="672"></p>
<p>Notice that the data at the middle of the observed period is
overdispersed, such that a Poisson model cannot properly address the
uncertainty. One could proposed the usage of a Normal model which,
indeed, could capture the uncertainty in the middle, but notice that the
data at the beginning and at the end of the series has very low values,
such that a Normal model would be inappropriate. In such scenario, a
better approach would be to add an noise component to the linear
predictor, such that it can capture the overdispersion:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">level</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">3</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.95</span></span>
<span><span class="op">)</span></span>
<span><span class="va">noise</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/noise_block.html">noise_block</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">level</span>, <span class="va">noise</span>,</span>
<span>  <span class="st">"Model 2"</span> <span class="op">=</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"mu"</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.data</span>, lag <span class="op">=</span> <span class="fl">1</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="structures_files/figure-html/unnamed-chunk-22-1.png" width="672"></p>
<p>It is relevant to point out that the choice of <code>R1</code> can
affect the final fit, as such, we highly recommend the user to perform a
sensibility analysis to help specify the value of <code>R1</code>.</p>
<p>Lastly, as we will see latter on, the noise block can also be useful
to model the dependency between multiple time series.</p>
<p>For a more detailed discussion of this type of blocks, see <span class="citation">dos Santos et al. (<a href="#ref-ArtigoMultivar">2024</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="handling-multiple-structural-blocks">Handling multiple structural blocks<a class="anchor" aria-label="anchor" href="#handling-multiple-structural-blocks"></a>
</h2>
<p>n the previous subsections, we discussed how to define the structure
of a model using the functions <code>polynomial_block</code>,
<code>regression_block</code>, <code>harmonic_block</code>,
<code>TF_block</code> and <code>noise_block</code>. Each of these
functions results in a single structural block. Generally, the user will
want to mix multiple types of structures, each one being responsible to
explain part of the outcome
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">Y_t</annotation></semantics></math>.
For this task, we introduce an operator designed to combine structural
blocks by superposition principle <span class="citation">(see <a href="#ref-WestHarr-DLM">West and Harrison, 1997, sec. 6.2</a>)</span>,
as follows.</p>
<p>Consider the scenario where one wishes to superimpose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
structural blocks; for instance: trend, seasonal and regression
components
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">p=3</annotation></semantics></math>).
A general overlaid structure is given by the following
specifications:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msubsup><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi><mn>1</mn></msubsup></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msubsup><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi><mi>n</mi></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mtd><mtd columnalign="right" style="text-align: right"><msub><mi>F</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msubsup><mi>F</mi><mi>t</mi><mn>1</mn></msubsup></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msubsup><mi>F</mi><mi>t</mi><mi>p</mi></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>G</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi><mo stretchy="false" form="prefix">{</mo><msubsup><mi>G</mi><mi>t</mi><mn>1</mn></msubsup><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msubsup><mi>G</mi><mi>t</mi><mi>p</mi></msubsup><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mtd><mtd columnalign="right" style="text-align: right"><msub><mi>W</mi><mi>t</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi><mo stretchy="false" form="prefix">{</mo><msubsup><mi>W</mi><mi>t</mi><mn>1</mn></msubsup><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msubsup><mi>W</mi><mi>t</mi><mi>p</mi></msubsup><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\vec{\theta}_t&amp;=\begin{bmatrix}\vec{\theta}_t^1\\ \vdots\\ \vec{\theta}_t^n\end{bmatrix}, &amp;
F_t&amp;=\begin{bmatrix}F_t^1 \\ 
\vdots \\ 
F_t^p\end{bmatrix},\\
G_t&amp;=diag\{G_t^{1},...,G_t^{p}\},&amp;
W_t&amp;=diag\{W_t^{1},...,W_t^{p}\},
\end{aligned}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi><mo stretchy="false" form="prefix">{</mo><msup><mi>M</mi><mn>1</mn></msup><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msup><mi>M</mi><mi>p</mi></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">diag\{M^1,...,M^{p}\}</annotation></semantics></math>
represents a block diagonal matrix such that its diagonal is composed of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mn>1</mn></msup><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msup><mi>M</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">M^1,...,M^{p}</annotation></semantics></math>;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_t</annotation></semantics></math>
is the vector obtained by the concatenation of the vectors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi><mn>1</mn></msubsup><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msubsup><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi><mi>p</mi></msubsup></mrow><annotation encoding="application/x-tex">\vec{\theta}_t^1,..., \vec{\theta}_t^p</annotation></semantics></math>
corresponding to each structural block; and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
is obtained as follows: if a single linear predictor is considered in
the model,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
is a line vector concatenating $F_t^1,…, F_t^p
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>.</mi><mi>F</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>o</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo stretchy="false" form="prefix">(</mo></mrow><annotation encoding="application/x-tex">. For the case of several predictors  (</annotation></semantics></math>k&gt;1$,
which will be seen in the next section), the design matrix associated to
structural block
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>F</mi><mi>t</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">F_t^i</annotation></semantics></math>,
has dimension $n_i k $ and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n \times k</annotation></semantics></math>
matrix, obtained by the row-wise concatenation of the matrices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>F</mi><mi>t</mi><mn>1</mn></msubsup><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msubsup><mi>F</mi><mi>t</mi><mi>p</mi></msubsup></mrow><annotation encoding="application/x-tex">F_t^1,..., F_t^p</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></msubsup><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n=\sum_{i=1}^p n_i</annotation></semantics></math>.</p>
<p>In this scenario, to facilitate the specification of such model, we
could create one structural block for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">\vec{\theta}_t^i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>F</mi><mi>t</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">F_t^{i}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>G</mi><mi>t</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">G_t^{i}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>W</mi><mi>t</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">W_t^{i}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">i=1,...p</annotation></semantics></math>,
and then “combine” all blocks together. The <strong>kDGLM</strong>
package allows this operation through the function
<code>block_superpos</code> or, equivalently, through the <code>+</code>
operator:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">block_1</span> <span class="op">&lt;-</span> <span class="va">...</span></span>
<span><span class="va">.</span></span>
<span><span class="va">.</span></span>
<span><span class="va">.</span></span>
<span><span class="va">block_n</span> <span class="op">&lt;-</span> <span class="va">...</span></span>
<span></span>
<span><span class="va">complete_structure</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/block_superpos.html">block_superpos</a></span><span class="op">(</span><span class="va">block_1</span>, <span class="va">...</span>, <span class="va">block_n</span><span class="op">)</span></span>
<span><span class="co"># or</span></span>
<span><span class="va">complete_structure</span> <span class="op">&lt;-</span> <span class="va">block_1</span> <span class="op">+</span> <span class="va">...</span> <span class="op">+</span> <span class="va">block_n</span></span></code></pre></div>
<p>For a very high number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
of structural blocks, the use of <code>block_superpos</code> is slightly
faster. To demonstrate the usage of the <code>+</code> operator, suppose
we would like to create a model using four of the structures presented
previously (a polynomial trend, a dynamic regression, a harmonic trend
and an AR model). We could do so with the following code:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">poly_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, name <span class="op">=</span> <span class="st">"Poly"</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span></span>
<span><span class="va">regr_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="va">X</span>, name <span class="op">=</span> <span class="st">"Regr"</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span></span>
<span><span class="va">harm_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, name <span class="op">=</span> <span class="st">"Harm"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">AR_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/tf_block.html">TF_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span>, noise.var <span class="op">=</span> <span class="fl">0.1</span>, name <span class="op">=</span> <span class="st">"AR"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">complete_block</span> <span class="op">&lt;-</span> <span class="va">poly_subblock</span> <span class="op">+</span> <span class="va">regr_subblock</span> <span class="op">+</span> <span class="va">harm_subblock</span> <span class="op">+</span> <span class="va">AR_subblock</span></span></code></pre></div>
<p>In the multiple regression context, that is, if more than one
regressor should be included in a predictor, the user must specify
different regression sub blocks, one for each regressor, and apply the
superposition principle to these blocks. Thus, in the previous code
lines, <code>X</code> is a vector with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
observations of a regressor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>t</mi></msub><annotation encoding="application/x-tex">X_t</annotation></semantics></math>,
already defined in an <strong>R</strong> object in the current
environment and cannot be a matrix of covariates. Ideally, the user
should also provide each block with a name to help identify them after
the model is fitted, but, if the user does not provide a name, the block
will have the default name for that type of block. If different blocks
have the same name, an index will be automatically added to the
variables with conflicting labels based on the order that the blocks
were combined. Note that the automatic naming might make the analysis of
the fitted model confusing, specially when dealing with a large number
of latent states. With that in mind, we <strong>strongly</strong>
recommend the users to specify an intuitive name for each structural
block.</p>
<p>When integrating multiple blocks within a model, it’s crucial to
understand how their associated design matrices, denoted as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>F</mi><mi>t</mi><mi>i</mi></msubsup><annotation encoding="application/x-tex">F_t^{i}</annotation></semantics></math>
for each block, are combined. These matrices are concatenated
vertically, one below the other. Consequently, since the predictor
vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>λ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\lambda}_t</annotation></semantics></math>
is calculated as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>t</mi></msub><mi>′</mi><msub><mover><mi>θ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">F_{t}'\vec{\theta}_t</annotation></semantics></math>,
the influence of each block on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>λ</mi><mo accent="true">→</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\vec{\lambda}_t</annotation></semantics></math>
is cumulative. In our previous code example, we introduced a linear
predictor named <code>eta</code>. In this context, the operations
performed in lines <code>1</code>, <code>5</code>, and <code>7</code>
(corresponding to <code>polynomial_block</code>,
<code>regression_block</code>, and <code>TF_block</code>, respectively),
are represented as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>t</mi><msub><mi>a</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>×</mo><msubsup><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow><mi>i</mi></msubsup><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">eta_t=1 \times \theta_{1,t}^{i},i=1,3,4</annotation></semantics></math>;
while in line <code>3</code> (corresponding to
<code>regression_block</code>), the operation is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>t</mi><msub><mi>a</mi><mi>t</mi></msub><mo>=</mo><msub><mi>X</mi><mi>t</mi></msub><mo>×</mo><msubsup><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">eta_t=X_t \times \theta_{1,t}^{2}</annotation></semantics></math>.
It’s important to note that each block initially defines
<code>eta</code> independently. However, when these blocks are combined,
their respective equations are merged. As a result, the complete
structure in line <code>9</code> can be expressed as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>t</mi><msub><mi>a</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>×</mo><msubsup><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow><mn>1</mn></msubsup><mo>+</mo><msub><mi>X</mi><mi>t</mi></msub><mo>×</mo><msubsup><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow><mn>2</mn></msubsup><mo>+</mo><mn>1</mn><mo>×</mo><msubsup><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow><mn>3</mn></msubsup><mo>+</mo><mn>1</mn><mo>×</mo><msubsup><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow><mn>4</mn></msubsup></mrow><annotation encoding="application/x-tex">
eta_t= 1 \times \theta_{1,t}^{1} + X_t \times \theta_{1,t}^{2} + 1 \times \theta_{1,t}^{3} + 1 \times \theta_{1,t}^{4}
</annotation></semantics></math></p>
<p>This expression illustrates how the contributions from each
individual block are aggregated to form the final model. This
methodology allows for the flexible construction of complex models by
combining simpler components, each contributing to explain a particular
facet of the process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>Y</mi><mi>t</mi></msub><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">\{Y_t\}_{t=1}^T</annotation></semantics></math>.</p>
</div>
<div class="section level2">
<h2 id="handling-multiple-linear-predictors">Handling multiple linear predictors<a class="anchor" aria-label="anchor" href="#handling-multiple-linear-predictors"></a>
</h2>
<p>As the user may have noticed, more then one argument can be passed in
the <code>...</code> argument. Indeed, if the user does so, several
linear predictors will be created in the same block (one for each unique
name), all of which are affected by the associated latent state. For
instance, take the following code:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># Common factor</span></span></code></pre></div>
<p>The code above creates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>
linear predictors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\lambda_{1,t}</annotation></semantics></math>,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\lambda_{2,t}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\lambda_{3,t}</annotation></semantics></math>
and a design matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>t</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>′</mi></mrow><annotation encoding="application/x-tex">F_t=(1,1,1)'</annotation></semantics></math>,
such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mn>1</mn><mo>×</mo><msub><mi>θ</mi><mi>t</mi></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mn>1</mn><mo>×</mo><msub><mi>θ</mi><mi>t</mi></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mn>1</mn><mo>×</mo><msub><mi>θ</mi><mi>t</mi></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\lambda_{1,t}&amp;=1 \times \theta_{t}\\
\lambda_{2,t}&amp;=1 \times \theta_{t}\\
\lambda_{3,t}&amp;=1 \times \theta_{t}
\end{aligned}
</annotation></semantics></math></p>
<p>Note that the latent state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_{t}</annotation></semantics></math>
is the same for all linear predictors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\lambda_{i,t}</annotation></semantics></math>,
i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_{t}</annotation></semantics></math>
is a shared effect among those linear predictors which could be used to
induce association among predictors. The specification of independent
effects to each linear predictor can be done by using different blocks
to each latent state:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_1</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_2</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># theta_3</span></span></code></pre></div>
<p>When the name of a linear predictor is missing from a particular
block, i.e., the name of a linear predictor was passed as an argument in
one block, but is absent in another, it is understood that particular
block has no effect on the linear predictor that is absent, such that
the previous code would be equivalent to:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Longer version of the previous code for the sake of clarity.</span></span>
<span><span class="co"># In general, when a block does not affect a particular linear predictor, that linear predictor should be ommited when creating the block.</span></span>
<span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">0</span>, lambda3 <span class="op">=</span> <span class="fl">0</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_1</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">0</span>, lambda2 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="fl">0</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_2</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">0</span>, lambda2 <span class="op">=</span> <span class="fl">0</span>, lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># theta_3</span></span></code></pre></div>
<p>As discussed in the end of Subsection <a href="structures.html#handling-multiple-structural-blocks">Handling
multiple structural blocks</a>, the effect of each block over the linear
predictors will be added to each other. As such both codes will create
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>
linear predictors, such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mn>1</mn><mo>×</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><mn>0</mn><mo>×</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><mn>0</mn><mo>×</mo><msub><mi>θ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mn>0</mn><mo>×</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><mn>1</mn><mo>×</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><mn>0</mn><mo>×</mo><msub><mi>θ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mn>0</mn><mo>×</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><mn>0</mn><mo>×</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><mn>1</mn><mo>×</mo><msub><mi>θ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>θ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\lambda_{1,t}&amp;=1 \times \theta_{1,t} + 0 \times \theta_{2,t} + 0 \times \theta_{3,t}=\theta_{1,t}\\
\lambda_{2,t}&amp;=0 \times \theta_{1,t} + 1 \times \theta_{2,t} + 0 \times \theta_{3,t}=\theta_{2,t}\\
\lambda_{3,t}&amp;=0 \times \theta_{1,t} + 0 \times \theta_{2,t} + 1 \times \theta_{3,t}=\theta_{3,t}
\end{aligned}
</annotation></semantics></math></p>
<p>Remind the syntax presented in the first illustration of the current
section, which guides the creation of common factors among predictors.
One can use multiple blocks in the same structure to define linear
predictors that share some (but not all) of their components:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_1</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_2</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_3</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># theta_4: Common factor</span></span></code></pre></div>
<p>representing the following structure:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>θ</mi><mrow><mn>4</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>θ</mi><mrow><mn>4</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>θ</mi><mrow><mn>4</mn><mo>,</mo><mi>t</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\lambda_{1,t}&amp;=\theta_{1,t}+\theta_{4,t}\\
\lambda_{2,t}&amp;=\theta_{2,t}+\theta_{4,t}\\
\lambda_{3,t}&amp;=\theta_{3,t}+\theta_{4,t}\\
\end{aligned}
</annotation></semantics></math></p>
<p>The examples above all have very basic structures, so as to not
overwhelm the reader with overly intricate models. Still, the
<strong>kDGLM</strong> package is not limited to in any way by the
inclusion of multiple linear predictors, such that any structure one may
use with a single predictor can also be used with multiple linear
predictors. For example, we could have a model with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>
linear predictors, each one having a mixture of shared components and
exclusive components:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#### Global level with linear growth ####</span></span>
<span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span>, order <span class="op">=</span> <span class="fl">2</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="co">#### Local variables for lambda1 ####</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="va">X1</span>, max.lag <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, D <span class="op">=</span> <span class="fl">0.98</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="co">#### Local variables for lambda2 ####</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/tf_block.html">TF_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span>, pulse <span class="op">=</span> <span class="va">X2</span>, order <span class="op">=</span> <span class="fl">1</span>, noise.disc <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, D <span class="op">=</span> <span class="fl">0.98</span>, order <span class="op">=</span> <span class="fl">2</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="co">#### Local variables for lambda3 ####</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/tf_block.html">TF_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">2</span>, noise.disc <span class="op">=</span> <span class="fl">0.9</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="va">X3</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span></code></pre></div>
<p>Now we focus on the replication of structural blocks, for which we
apply <code>block_mult</code> function and the associated operator
<code>*</code>. This function allows the user to create multiple blocks
with identical structure, but each one being associated with a different
linear predictor. The usage of this function is as simple as:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">base.block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, name <span class="op">=</span> <span class="st">"Poly"</span>, D <span class="op">=</span> <span class="fl">0.95</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># final.block &lt;- block_mult(base.block, 4)</span></span>
<span><span class="co"># or</span></span>
<span><span class="co"># final.block &lt;- base.block * 4</span></span>
<span><span class="co"># or</span></span>
<span><span class="va">final.block</span> <span class="op">&lt;-</span> <span class="fl">4</span> <span class="op">*</span> <span class="va">base.block</span></span></code></pre></div>
<p>When replicating blocks, it is understood that each copy of the base
block is independent of each other (i.e., they have their own latent
states) and each block is associated with a different set of linear
predictors. The name of the linear predictors associated with each block
are taken to be the original names with an index:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">final.block</span><span class="op">$</span><span class="va">pred.names</span></span></code></pre></div>
<pre><code>[1] "eta.1" "eta.2" "eta.3" "eta.4"</code></pre>
<p>Naturally, the user might want to rename the linear predictors to a
more intuitive label. For such task, we provide the function:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">final.block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/block_rename.html">block_rename</a></span><span class="op">(</span><span class="va">final.block</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Matthew"</span>, <span class="st">"Mark"</span>, <span class="st">"Luke"</span>, <span class="st">"John"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">final.block</span><span class="op">$</span><span class="va">pred.names</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="handling-unknown-components-in-the-planning-matrix-f_t">Handling unknown components in the planning matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math><a class="anchor" aria-label="anchor" href="#handling-unknown-components-in-the-planning-matrix-f_t"></a>
</h2>
<p>In some situations the user may want to fit a model such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>λ</mi><mi>t</mi></msub><mo>=</mo><msub><mi>F</mi><mi>t</mi></msub><mi>′</mi><msub><mi>θ</mi><mi>t</mi></msub><mo>=</mo><mi>⋯</mi><mo>+</mo><msub><mi>ϕ</mi><mi>t</mi></msub><msub><mi>θ</mi><mi>t</mi></msub><mo>+</mo><mi>⋯</mi><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\lambda_{t}=F_t'\theta_t=\cdots+\phi_t\theta_t +\cdots,
\end{aligned}
</annotation></semantics></math> in other words, it may be the case that
the planning matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
contains one or more unknown components. This idea may be foreign when
working with only one linear predictor, but if our observational model
has several predictors it could make sense to have shared effects among
predictors. Besides, this construction is also natural when modeling
multiple time series simultaneously, such as when dealing with
correlated outcomes or when working with a compound regression. All
those cases will be explored in the Advanced Examples section of the
vignette. For now, we will focus on <strong>how</strong> to specify such
structures, whatever their use may be.</p>
<p>For simplicity, let us assume that we want to create a linear
predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\lambda_t</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>t</mi></msub><mo>=</mo><msub><mi>ϕ</mi><mi>t</mi></msub><msub><mi>θ</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_{t}=\phi_t\theta_t</annotation></semantics></math>.
Then the first step would be to create a linear predictor associated
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
(which we will call <code>phi</code>, although the user may call it
whatever it pleases the user):</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">phi_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>phi <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>Notice that we are creating a linear predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
and a latent state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mi>t</mi></msub><annotation encoding="application/x-tex">\tilde{\theta}_t</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϕ</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>×</mo><msub><mover><mi>θ</mi><mo accent="true">̃</mo></mover><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\phi_t=1\times \tilde{\theta}_t</annotation></semantics></math>.
Also, it is important to note that the structure for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϕ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\phi_t</annotation></semantics></math>
could be any other structural block (harmonic, regression, auto
regression, etc.).</p>
<p>Now we can create a structural block for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_t</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">theta_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"phi"</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>The code above creates a linear predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\lambda_t</annotation></semantics></math>
and a latent state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_t</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>t</mi></msub><mo>=</mo><msub><mi>ϕ</mi><mi>t</mi></msub><mo>×</mo><msub><mi>θ</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_t=\phi_t \times \theta_t</annotation></semantics></math>.
Notice that the <code>...</code> argument of any structural block is
used to specify the planning matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>,
specifically, the user must provide a list of named values, where each
name indicates a linear predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\lambda_t</annotation></semantics></math>
and its associated value represent the effect of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_{t}</annotation></semantics></math>
in this predictor. When the user pass a string in <code>...</code>, it
is implicitly that the component of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
associated with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\theta_t</annotation></semantics></math>
is unknown and modeled by the linear predictor labelled as the passed
string.</p>
<p>Lastly, as one could guess, it is possible to establish a chain of
components in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
in order to create an even more complex structure. For instance, take
the following code:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta1 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta2 <span class="op">=</span> <span class="st">"eta1"</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta3 <span class="op">=</span> <span class="st">"eta2"</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>In the first line we create a linear predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\eta_{1,t}</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><mn>1</mn><mo>×</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\eta_{1,t}=1 \times \theta_{1,t}</annotation></semantics></math>.
In the second line we create another linear predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\eta_{2,t}</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>η</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>×</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>×</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\eta_{2,t}=\eta_{1,t} \times \theta_{2,t}=\theta_{1,t} \times \theta_{2,t}</annotation></semantics></math>.
Then we create a linear predictor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\eta_{3,t}</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>η</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>×</mo><msub><mi>θ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>θ</mi><mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>×</mo><msub><mi>θ</mi><mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub><mo>×</mo><msub><mi>θ</mi><mrow><mn>3</mn><mo>,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\eta_{3,t}=\eta_{2,t} \times \theta_{3,t}=\theta_{1,t} \times \theta_{2,t} \times \theta_{3,t}</annotation></semantics></math>.</p>
<p>To fit models with non-linear components in the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math>
and/or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>t</mi></msub><annotation encoding="application/x-tex">G_t</annotation></semantics></math>
matrices, we use the Extended Kalman Filter <span class="citation">(<a href="#ref-Kalman_filter_origins">Kalman, 1960</a>; <a href="#ref-WestHarr-DLM">West and Harrison, 1997</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="special-priors">Special priors<a class="anchor" aria-label="anchor" href="#special-priors"></a>
</h2>
<p>As discussed in Subsection <a href="structures.html#a-structure-for-polynomial-trend-models">A
structure for polynomial trend models</a>, the default prior for the
polynomial block—as well as for other blocks—assumes that the latent
states are independent with a mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
and a variance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>9</mn><annotation encoding="application/x-tex">9</annotation></semantics></math>.
Users have the flexibility to modify this prior to any combination of
mean vector and covariance matrix, although the latent states of
different blocks are always assumed to be independent. It is important
to note that this independence applies only to the prior distribution;
subsequent updates may induce correlations between the latent
states.</p>
<p>While this prior setup may be appropriate for a broad range of
applications, there may be instances where a user needs to apply a joint
prior for latent states across different blocks. For example, if a
similar model has previously been fitted to another dataset, an analyst
might wish to integrate information from this prior model into the new
fitting. To facilitate the specification of a joint prior for any set of
latent states, the <strong>kDGLM</strong> package offers the
<code>joint_prior</code> function:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/joint_prior.html">joint_prior</a></span><span class="op">(</span><span class="va">block</span>, var.index <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">block</span><span class="op">$</span><span class="va">n</span>, a1 <span class="op">=</span> <span class="va">block</span><span class="op">$</span><span class="va">a1</span><span class="op">[</span><span class="va">var.index</span><span class="op">]</span>, R1 <span class="op">=</span> <span class="va">block</span><span class="op">$</span><span class="va">R1</span><span class="op">[</span><span class="va">var.index</span>, <span class="va">var.index</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>The <code>joint_prior</code> function accepts a
<code>dlm_block</code> object and returns the same object with a
modified prior.</p>
<p>The <code>block</code> argument is a <code>dlm_block</code> object.
The syntax of this function is designed to facilitate the use of the
pipe operator (either <code>|&gt;</code> or <code>%&gt;%</code>),
allowing for seamless integration into piped sequences. For example:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">2</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/block_mult.html">block_mult</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/joint_prior.html">joint_prior</a></span><span class="op">(</span>a1 <span class="op">=</span> <span class="va">prior.mean</span>, R1 <span class="op">=</span> <span class="va">prior.var</span><span class="op">)</span></span>
<span><span class="co"># assuming the objects prior.mean and prior.var are defined.</span></span></code></pre></div>
<p>The <code>var.index</code> argument is optional and indicates the
indexes of the latent states for which the prior distribution will be
modified.</p>
<p>The <code>a1</code> and <code>R1</code> arguments represent,
respectively, the mean vector and the covariance matrix for the latent
states that the user wishes to modify the prior for.</p>
<p>The user may also want to specify some special priors that impose a
certain structure for the data. For instance, the user may believe that
a certain set of latent state sum to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
or that there is a spacial structure to them. This is specially relevant
when modelling multiple time series, for instance, lets say that we have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>
series
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">Y_{i,t}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">i=1,...r</annotation></semantics></math>,
such that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>Y</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>η</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>λ</mi><mrow><mi>i</mi><mi>t</mi></mrow></msub><mo>=</mo><msub><mi>μ</mi><mi>t</mi></msub><mo>+</mo><msub><mi>α</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></munderover><msub><mi>α</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mn>0</mn><mo>,</mo><mo>∀</mo><mi>t</mi><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}    
Y_{i,t}|\eta_{i,t} &amp;\sim Poisson(\eta_{i,t})\\
\ln(\eta_{i,t})&amp;=\lambda_{it}=\mu_t+\alpha_{i,t},\\
\sum_{i=1}^{r} \alpha_{i,t}&amp;=0, \forall t.
\end{aligned}
</annotation></semantics></math></p>
<p>Similarly, one could want to specify a CAR prior <span class="citation">(<a href="#ref-banerjee2014hierarchical">Banerjee et
al., 2014</a>; <a href="#ref-AlexCar">Schmidt and Nobre,
2018</a>)</span> for the variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><msub><mi>α</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_1,...\alpha_r</annotation></semantics></math>,
if the user believes there is spacial autocorrelation.</p>
<p>For these scenarios, the <strong>kDGLM</strong> package provides
functions to facilitate the specification of special priors for
structural blocks, such as the <code>zero_sum_prior</code> and the
<code>CAR_prior</code>. Their general usage is analogous to the
<code>joint_prior</code> function. Details on these functions will be
omitted in this document for the sake of brevity. For comprehensive
usage instructions, please refer to the vignette or the associated
documentation.</p>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-banerjee2014hierarchical" class="csl-entry">
Banerjee, S., Carlin, B. P., and Gelfand, A. E. (2014). <em>Hierarchical
modeling and analysis for spatial data</em>. Chapman; Hall/CRC.
</div>
<div id="ref-ArtigoMultivar" class="csl-entry">
dos Santos, S. V., Junior, Alves, M. B., and Migon, H. S. (2024). An
efficient sequential approach for joint modelling of multiple time
series.
</div>
<div id="ref-Kalman_filter_origins" class="csl-entry">
Kalman, R. E. (1960). A new approach to linear filtering and prediction
problems. <em>Transactions of the ASME–Journal of Basic
Engineering</em>, <em>82</em>(Series D), 35–45.
</div>
<div id="ref-AlexCar" class="csl-entry">
Schmidt, A. M., and Nobre, W. S. (2018). <a href="https://doi.org/10.1002/9781118445112.stat08048" class="external-link">Conditional
autoregressive (CAR) model</a>. In <em>Wiley StatsRef: Statistics
reference online</em>, pages 1–11. John Wiley &amp; Sons, Ltd.
</div>
<div id="ref-WestHarr-DLM" class="csl-entry">
West, M., and Harrison, J. (1997). <em>Bayesian forecasting and dynamic
models (springer series in statistics)</em>. Hardcover; Springer-Verlag.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Silvaneo dos Santos Jr., Mariane Branco Alves, Hélio dos Santos Migon.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
