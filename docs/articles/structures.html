<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="kDGLM">
<title>Creation of model structures • kDGLM</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Creation of model structures">
<meta property="og:description" content="kDGLM">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light" data-bs-theme="light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">kDGLM</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.2.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/intro.html">Introduction</a>
    <a class="dropdown-item" href="../articles/structures.html">Creation of model structures</a>
    <a class="dropdown-item" href="../articles/outcomes.html">Creation of model outcomes</a>
    <a class="dropdown-item" href="../articles/fitting.html">Fitting and analysing models</a>
    <a class="dropdown-item" href="../articles/example1.html">Space-time model hospital admissions from gastroenteritis</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/silvaneojunior/kDGLM/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Creation of model structures</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/silvaneojunior/kDGLM/blob/HEAD/vignettes/structures.Rmd" class="external-link"><code>vignettes/structures.Rmd</code></a></small>
      <div class="d-none name"><code>structures.Rmd</code></div>
    </div>

    
    
<style>
body {
text-align: justify}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script><div class="section level2">
<h2 id="table-of-contents">Table of contents<a class="anchor" aria-label="anchor" href="#table-of-contents"></a>
</h2>
<ol>
<li>
<details><summary><a href="intro.html">Introduction:</a> &gt;
</summary><ul>
<li>
<a href="intro.html#introduction">Introduction</a>
</li>
<li>
<a href="intro.html#notation">Notation</a>
</li>
</ul></details>
</li>
<li>
<details><summary><a href="structures.html">Creating the model structure:</a> &gt;
</summary><ul>
<li>
<a href="structures.html#a-structure-for-polynomial-trend-models">A
structure for polynomial trend models</a>
</li>
<li>
<a href="structures.html#a-structure-for-dynamic-regression-models">A
structure for dynamic regression models</a>
</li>
<li>
<a href="structures.html#a-structure-for-harmonic-trend-models">A
structure for harmonic trend models</a>
</li>
<li>
<a href="structures.html#a-structure-for-autoregresive-models">A
structure for autoregresive models</a>
</li>
<li>
<a href="structures.html#a-structure-for-overdispersed-models">A
structure for overdispersed models</a>
</li>
<li>
<a href="structures.html#handling-multiple-structural-blocks">Handling
multiple structural blocks</a>
</li>
<li>
<a href="structures.html#handling-multiple-linear-predictors">Handling
multiple linear predictors</a>
</li>
<li>
<a href="structures.html#handling-unknown-components-in-the-planning-matrix-f_t">Handling
unknown components in the planning matrix <span class="math inline">\(F_t\)</span></a>
</li>
<li>
<a href="structures.html#special-priors">Special priors</a>
</li>
</ul></details>
</li>
<li>
<details><summary><a href="outcomes.html">Creating the model outcome:</a> &gt;
</summary><ul>
<li>
<a href="outcomes.html#normal-case">Normal case</a>
</li>
<li>
<a href="outcomes.html#poisson-case">Poisson case</a>
</li>
<li>
<a href="outcomes.html#gamma-case">Gamma case</a>
</li>
<li>
<a href="outcomes.html#multinomial-case">Multinomial case</a>
</li>
<li>
<a href="outcomes.html#handling-multiple-outcomes">Handling multiple
outcomes</a>
</li>
</ul></details>
</li>
<li>
<details><summary><a href="fitting.html">Fitting and analysing models:</a> &gt;
</summary><ul>
<li>
<a href="fitting.html#filtering-and-smoothing">Filtering and
smoothing</a>
</li>
<li>
<a href="fitting.html#extracting-components">Extracting components</a>
</li>
<li>
<a href="fitting.html#forecasting">Forecasting</a>
</li>
<li>
<a href="fitting.html#intervention-and-monitoring">Intervention and
monitoring</a>
</li>
<li>
<a href="fitting.html#tools-for-sensibility-analysis">Tools for
sensibility analysis</a>
</li>
<li>
<a href="fitting.html#sampling-and-hyper-parameter-estimation">Sampling
and hyper parameter estimation</a>
</li>
</ul></details>
</li>
<li>
<details><summary>
Advanced examples:&gt;
</summary><ul><li>
<a href="example1.html">Space-time model hospital admissions from
gastroenteritis</a>
</li></ul></details>
</li>
</ol>
</div>
<div class="section level2">
<h2 id="creation-of-model-structures">Creation of model structures<a class="anchor" aria-label="anchor" href="#creation-of-model-structures"></a>
</h2>
<p>In this section we will discuss the specification of the model
structure. We will consider the structure of a model as all the elements
that determine the relation between our linear predictor <span class="math inline">\(\vec{\lambda}_t\)</span> and our latent states
<span class="math inline">\(\vec{\theta}_t\)</span> though time. Thus,
the present section is dedicated to the definition of the following,
highlighted equations from a general dynamic generalized model:</p>
<p><span class="math display">\[
\require{color}
\begin{equation}
\begin{aligned}
Y_t|\eta_t &amp;\sim \mathcal{F}\left(\eta_t\right),\\
g(\eta_t) &amp;= {\color{red}\lambda_{t}=F_t'\theta_t,}\\
{\color{red}\theta_t }&amp;{\color{red}=G_t\theta_{t-1}+\omega_t,}\\
{\color{red}\omega_t }&amp;{\color{red}\sim \mathcal{N}_n(h_t,W_t)}.
\end{aligned}
\end{equation}
\]</span></p>
<p>Namely, we consider that the structure of a model consists of the
matrices/vectors <span class="math inline">\(F_t\)</span>, <span class="math inline">\(G_t\)</span>, <span class="math inline">\(\vec{h}_t\)</span>, <span class="math inline">\(H_t\)</span> and <span class="math inline">\(D_t\)</span>.</p>
<p>Although we allow the user to manually define each entry of each of
those matrices (which we <strong>do not</strong> recommend), we also
offer tools to simplify this task. Currently, we offer support for the
following base structures:</p>
<ul>
<li>
<code>polynomial_block</code>: Structural block for polynomial
trends <span class="citation">(see <a href="#ref-WestHarr-DLM">West and
Harrison, 1997, Chapter 7</a>)</span>. As special cases, this block has
support for random walks and linear growth models.</li>
<li>
<code>harmonic_block</code>: Structural block for seasonal trends
using harmonics <span class="citation">(see <a href="#ref-WestHarr-DLM">West and Harrison, 1997, Chapter
8</a>)</span>.</li>
<li>
<code>regression_block</code>: Structural block for (dynamic)
regressions <span class="citation">(see <a href="#ref-WestHarr-DLM">West
and Harrison, 1997, Chapter 6</a> and 9)</span>.</li>
<li>
<code>TF_block</code>: Structural block for autoregressive
components and transfer functions <span class="citation">(see <a href="#ref-WestHarr-DLM">West and Harrison, 1997, Chapter 9</a> and
13)</span>.</li>
<li>
<code>noise_block</code>: Structural block for random effects <span class="citation">dos Santos et al. (<a href="#ref-ArtigoMultivar">2024</a>)</span>.</li>
</ul>
<p>For the sake of brevity, we will present only the details for the
<code>polynomial_block</code>, since all other functions have very
similar usage (the full description of each block can be found in the
vignette, in the reference manual and in their respective help
pages).</p>
<p>Along with the aforementioned functions, we also present some
auxiliary functions and operations to help the user manipulate created
structural blocks.</p>
<p>In Subsections <a href="structures.html#a-structure-for-polynomial-trend-models">A
structure for polynomial trend models</a>, <a href="structures.html#a-structure-for-dynamic-regression-models">A
structure for dynamic regression models</a>, <a href="structures.html#a-structure-for-harmonic-trend-models">A structure
for harmonic trend models</a>, <a href="structures.html#a-structure-for-autoregresive-models">A structure
for autoregresive models</a> and <a href="structures.html#a-structure-for-overdispersed-models">A structure
for overdispersed models</a> introduce the several functions design to
facilitate the creation of single structural blocks. In those sections
we begin by examining simplistic models, characterized by a single
structural block and one linear predictor, with a completely known <span class="math inline">\(F_t\)</span> matrix. Subsection <a href="structures.html#handling-multiple-structural-blocks">Handling
multiple structural blocks</a> builds upon these concepts, exploring
models that incorporate multiple structural blocks while maintaining a
singular linear predictor. The focus shifts in Subsection <a href="structures.html#handling-multiple-linear-predictors">Handling
multiple linear predictors</a>, where we delve into the specification of
multiple linear predictors within the same model. In Section <a href="structures.html#handling-unknown-components-in-the-planning-matrix-f_t">Handling
unknown components in the planning matrix <span class="math inline">\(F_t\)</span></a>, the discussion turns to
scenarios where <span class="math inline">\(F_t\)</span> includes one or
more unknown components. Finally, Subsection <a href="structures.html#special-priors">Special priors</a> provides a
brief examination of functions used to define specialized priors.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-polynomial-trend-models">A structure for polynomial trend models<a class="anchor" aria-label="anchor" href="#a-structure-for-polynomial-trend-models"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span><span class="va">...</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>, name <span class="op">=</span> <span class="st">"Var.Poly"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">1</span>, h <span class="op">=</span> <span class="fl">0</span>, H <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>, R1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">9</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Recall the notation introduced in Section <a href="intro.html#notation">Notation</a> and revisited at the beginning
of this vignette. The <code>polynomial_block</code> function will create
a structural block based on <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 7. This involves the
creation of a latent vector <span class="math inline">\(\vec{\theta}_t=(\theta_{1,t},...,\theta_{n,t})'\)</span>,
such that:</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
\theta_{i,t} &amp;= \theta_{i,t-1}+\theta_{i+1, t-1}+\omega_{i,t},
i=1,...,n-1\\
\theta_{n,t} &amp;= \theta_{n,t-1}+\omega_{n,t},\\
\theta_1&amp;\sim \mathcal{N}_k(a_1,R_1),\\
\omega_{1,t},...,\omega_{n,t}&amp;\sim \mathcal{N}_n(\vec{h}_t,W_t),
\end{aligned}
\label{eq:defpol}
\end{equation}\]</span></p>
<p>where <span class="math inline">\(W_t=Var[\theta_t|\mathcal{D}_{t-1}]\odot (1-D_t)
\oslash D_t+H_t\)</span>.</p>
<p>Let’s dissect each component of this specification.</p>
<p>The <code>order</code> argument sets the polynomial block’s order,
correlating <span class="math inline">\(n\)</span> with the value
passed.</p>
<p>The optional <code>name</code> argument aids in identifying each
structural block in post-fitting analysis, such as plotting or result
examination (see Section <a href="fitting.html">Fitting and analysing
models</a>).</p>
<p>The <code>D</code>, <code>h</code>, <code>H</code>, <code>a1</code>,
and <code>R1</code> arguments correspond to <span class="math inline">\(D_t\)</span>, <span class="math inline">\(\vec{h}_t\)</span>, <span class="math inline">\(H_t\)</span>, <span class="math inline">\(\vec{a}_1\)</span> and <span class="math inline">\(R_1\)</span>, respectively.</p>
<p><code>D</code> specifies the discount matrices over time. Its format
varies: a scalar implies a constant discount factor; a vector of size
<span class="math inline">\(T\)</span> (the length of the time series)
means varying discount factors over time; a <span class="math inline">\(n\times n\)</span> matrix indicates that the same
discount matrix is given by <code>D</code> and is the same for all
times; a 3D-array of dimension <span class="math inline">\(n\times
n\times T\)</span> indicates time-specific discount matrices. Any other
shape for <code>D</code> is considered invalid.</p>
<p><code>h</code> specifies the drift vector over time. If
<code>h</code> is a scalar, it is understood that the drift is the same
for all variables at all time. If <code>h</code> is a vector of size
<span class="math inline">\(T\)</span>, then it is understood that the
drift is the same for all variables, but have different values for each
time, such that each coordinate <span class="math inline">\(t\)</span>
of <code>h</code> represents the drift for time <span class="math inline">\(t\)</span>. If <code>h</code> is a <span class="math inline">\(n \times T\)</span> matrix, then we assume that
the drift vector at time <span class="math inline">\(t\)</span> is given
by <code>h[,t]</code>. Any other shape for <code>h</code> is considered
invalid.</p>
<p>The argument <code>H</code> follows the same syntax as
<code>D</code>, since the matrix <span class="math inline">\(H_t\)</span> has the same shape as <span class="math inline">\(D_t\)</span>.</p>
<p>The argument <code>a1</code> and <code>R1</code> are used to define,
respectively the mean and the covariance matrix for the prior for <span class="math inline">\(\theta_1\)</span>. If <code>a1</code> is a scalar,
it is understood that all latent states associated with this block have
the same prior mean; if <code>a1</code> is a vector of size <span class="math inline">\(n\)</span>, then it is understood that the prior
mean <span class="math inline">\(a_1\)</span> is given by
<code>a1</code>. If <code>R1</code> is a scalar, it is understood that
the latent states have independent priors with the same variance (this
does not imply that they will have independent posteriors); if
<code>R1</code> is a vector of size <span class="math inline">\(n\)</span>, it is understood that the latent
states have independent priors and that the prior variance for the <span class="math inline">\(\theta_{i,1}\)</span> is given by
<code>R1[i]</code>; if <code>R1</code> is a <span class="math inline">\(n \times n\)</span> matrix, it is understood that
<span class="math inline">\(R_1\)</span> is given by <code>R1</code>.
Any other shape for <code>a1</code> or <code>R1</code> are considered
invalid.</p>
<p>The arguments <code>D</code>, <code>h</code>, <code>H</code>,
<code>a1</code>, and <code>R1</code> can accept character values,
indicating that certain parameters are not fully defined. In such cases,
the dimensions of these arguments are interpreted in the same manner as
their numerical counterparts. For instance, if <code>D</code> is a
single character, it implies a uniform, yet unspecified, discount factor
across all variables and time points, with <code>D</code> serving as a
placeholder label. Should <code>D</code> be a vector of length <span class="math inline">\(T\)</span> (the time series length), it suggests
varying discount factors over time, with each character entry in the
vector (e.g., <code>D[i]</code>) acting as a label for the discount
factor at the respective time point. This logic extends to the other
arguments and their various dimensional forms. It’s crucial to recognize
that if these arguments are specified as labels rather than explicit
values, the corresponding model block is treated as “undefined,”
indicating the absence of a key hyperparameter. Consequently, a model
with an undefined block cannot be fitted. Users must either employ the
<code>specify.dlm_block</code> method to replace labels with concrete
values or pass the value of the value of those hyper-parameter as named
values to the <code>fit_model</code> function to systematically evaluate
models with different values for these labels. Section <a href="fitting.html#tools-for-sensitivity-analysis">Tools for sensitivity
analysis</a> elaborates on the available tools for sensitivity analysis.
Further information about both <code>specify</code> and
<code>fit_model</code> is available in the reference manual or through
the <code>help</code> function.</p>
<p>Notice that the user does not need to specify the matrix <span class="math inline">\(G_t\)</span>, since it is implicitly determined by
the equation <span class="math inline">\(\eqref{eq:defpol}\)</span> and
the order of the polynomial block. Each type of block will define it own
matrix <span class="math inline">\(G_t\)</span>, as such, the user does
not need to worry about <span class="math inline">\(G_t\)</span>, except
in very specific circumstances, where an advanced user may need a type
of model that is not yet implemented.</p>
<p>The argument <code>...</code> is used to specify the matrix <span class="math inline">\(F_t\)</span> (see details in Subsection <a href="structures.html#handling-multiple-linear-predictors">Handling
multiple linear predictors</a>). Specifically, the user must provide a
list of named values which are arbitrary labels to each linear predictor
<span class="math inline">\(\lambda_{i,t}\)</span> , <span class="math inline">\(i=1,\ldots,k\)</span>, and its associated value
represents the effect of the level <span class="math inline">\(\theta_{1,t}\)</span> (see Eq. <span class="math inline">\(\eqref{eq:defpol}\)</span>) in this predictor.</p>
<p>For example, consider a polynomial block of order <span class="math inline">\(2\)</span>, representing a linear growth. If the
user passes an extra argument <code>lambda</code> (the naming is
arbitrary) as <span class="math inline">\(1\)</span>, then the matrix
<span class="math inline">\(F_t\)</span> is created as:</p>
<p><span class="math display">\[
F_t=\begin{bmatrix}1\\0\end{bmatrix}
\]</span></p>
<p>Note that, as the polynomial block has order <span class="math inline">\(2\)</span>, it has <span class="math inline">\(2\)</span> latent states, <span class="math inline">\(\theta_{1,t}\)</span> and <span class="math inline">\(\theta_{2,t}\)</span>. While <span class="math inline">\(\theta_{2,t}\)</span> does not affect the linear
predictor <code>lambda</code> directly, it serves as an auxiliary
variable to induce a more complex dynamic for <span class="math inline">\(\theta_{1,t}\)</span>. Indeed, by Equation <span class="math inline">\(\eqref{eq:defpol}\)</span>, we have that a second
order polynomial block have the following temporal evolution:</p>
<p><span class="math display">\[
\begin{aligned}
\theta_{1,t} &amp;= \theta_{1,t-1}+\theta_{2, t-1}+\omega_{1,t}\\
\theta_{2,t} &amp;= \theta_{2,t-1}+\omega_{2,t},\\
\omega_{1,t},\omega_{2,t}&amp;\sim \mathcal{N}_2(\vec{h}_t,W_t).
\end{aligned}
\]</span></p>
<p>As such, <span class="math inline">\(\theta_{2,t}\)</span> represents
a growth factor that is added in <span class="math inline">\(\theta_{1,t}\)</span> and smoothly changes
overtime. Even more complex structures can be defined, either by a
higher order polynomial block or by one of the several other types of
block offered by the <em><code>kDGLM</code></em>.</p>
<p>The specification of values associated to each predictor label is
further illustrated in the examples further exhibited in this
section.</p>
<p>Lastly, the argument <code>monitoring</code> shall be explained
later, in Subsection <a href="fitting.html#intervention-and-monitoring">Intervention and
monitoring</a>, which discusses automated monitoring and
interventions.</p>
<p>To exemplify the usage of this function, let us assume that we have a
simple Normal model with known variance <span class="math inline">\(\sigma^2\)</span>, in which <span class="math inline">\(\eta\)</span> is the mean parameter and the link
function <span class="math inline">\(g\)</span> is such that <span class="math inline">\(g(\eta)=\eta\)</span>. Let us also assume that the
mean is constant over time and we have no explanatory variables, so that
our model can be simply written as:</p>
<p><span class="math display">\[
\begin{aligned}
Y_t|\theta_t &amp;\sim \mathcal{N}_1\left(\eta_t, \sigma^2\right),\\
\eta_t &amp;={\color{red}\lambda_{t}=\theta_t,}\\
{\color{red}\theta_t} &amp;{\color{red}=\theta_{t-1}=\theta.}
\end{aligned}
\]</span></p>
<p>In this case, we have <span class="math inline">\(F_t=1\)</span>,
<span class="math inline">\(G_t=1\)</span>, <span class="math inline">\(D_t=1\)</span>, <span class="math inline">\(h_t=0\)</span> and <span class="math inline">\(H_t=0\)</span>, for all <span class="math inline">\(t\)</span>. Assuming a prior distribution <span class="math inline">\(\mathcal{N}(0,9)\)</span> for <span class="math inline">\(\theta\)</span>, we can create the highlighted
structure using the following code:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span>, name <span class="op">=</span> <span class="st">"Mean"</span><span class="op">)</span></span></code></pre></div>
<p>Setting <code>eta=1</code>, we specify that there is a linear
predictor named <em>eta</em>, and that <span class="math inline">\(eta =
1 \times \theta\)</span>. Setting <code>order = 1</code>, we specify
that <span class="math inline">\(\theta_t\)</span> is a scalar and that
<span class="math inline">\(G_t=1\)</span>. We can omit the values of
<code>a1</code> , <code>R1</code>, <code>D</code>, <code>h</code> and
<code>H</code>, since the default values reflect the specified model. We
could also omit the argument <code>order</code>, since the default is
<span class="math inline">\(1\)</span>, but we chose to explicit define
it so as to emphasize its usage. The argument <code>name</code>
specifies a label for the created block; in this case, we chose to call
it “Mean”, to help identify its role in our model.</p>
<p>Suppose now that we have an explanatory variable <span class="math inline">\(X\)</span> that we would like to introduce in our
model to help explain the behavior of <span class="math inline">\(\eta_t\)</span>. We could similarly define such
structure by creating an additional block such as:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="va">X</span>, name <span class="op">=</span> <span class="st">"Var X"</span><span class="op">)</span></span></code></pre></div>
<p>By setting <code>eta=X</code>, we specify that there is a linear
predictor called <em>eta</em>, and that <span class="math inline">\(eta
= X \times \theta\)</span>. If <span class="math inline">\(X=(X_1,...,X_T)'\)</span> is a vector, then we
would have <span class="math inline">\(F_t=X_t\)</span>, for each <span class="math inline">\(t\)</span>, such that <span class="math inline">\(eta_t = X_t \times \theta\)</span>.</p>
<p>It should be noted that <code>kDGLM</code> has a specific structural
block designed for regressions, <code>regression_block</code>, but we
also allow any structural block to be used for a regression, by just
setting the value assigned to the predictor equal to the regressor
vector <span class="math inline">\(X_t, t=1, \ldots, X_T\)</span>.</p>
<p>The user can specify complex temporal dynamics for the effects of any
co-variate. For instance, it could be assumed that a regressor has a
seasonal effect on a linear predictor. This this could be accommodated
by the insertion of the values of the regressor associated to a seasonal
block. The use of seasonal blocks is illustrated in Section <a href="example1.html">Space-time model hospital admissions from
gastroenteritis</a>.</p>
<p>So far, we have only discussed the creation of static latent effects,
but the inclusion of stochastic temporal dynamics is very
straightforward. One must simply specify the values of <code>H</code> to
be greater than <span class="math inline">\(0\)</span> and/or the values
of <code>D</code> to be lesser than <span class="math inline">\(1\)</span>:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span>, name <span class="op">=</span> <span class="st">"Mean"</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span></code></pre></div>
<p>Notice that a dynamic regression model could be obtained by assigning
<code>eta=X</code> in the previous code line. Bellow we present a plot
of two simple trend models fitted to the same data: one with a static
mean and another using a dynamic mean.</p>
<p>In the following example we use the functions <code>Normal</code>,
<code>fit_model</code> and the <code>plot</code> method. We advise the
reader to initially concentrate solely on the application of the
<code>polynomial_block</code>. The functionalities and detailed usage of
the other functions and methods, <code>Normal</code>,
<code>fit_model</code>, and <code>plot</code>, will be explored in later
sections, specifically in Sections <a href="outcomes.html">Creating the
model outcome:</a> and <a href="fitting.html">Fitting and analysing
models:</a>. The inclusion of these functions in the current example is
primarily to offer a comprehensive and operational code sample.</p>
<p><img src="structures_files/figure-html/unnamed-chunk-6-1.png" width="672"></p>
<p>For an extensive presentation and thorough discussion of the
theoretical aspects underlying the structure highlighted in this
section, interested readers are encouraged to consult <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, Chapters 6, 7, and 9.
Additionally, we strongly recommend that all users refer to the
associated documentation for more detailed information. This can be
accessed by using the <code><a href="../reference/polynomial_block.html">help(polynomial_block)</a></code> function or
consulting the reference manual.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-dynamic-regression-models">A structure for dynamic regression models<a class="anchor" aria-label="anchor" href="#a-structure-for-dynamic-regression-models"></a>
</h2>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span><span class="va">...</span>,</span>
<span>  max.lag <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  zero.fill <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var.Reg"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1 <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">max.lag</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The <code>regression_block</code> function creates a structural block
for a dynamic regression with covariate <span class="math inline">\(X_t\)</span>, as specified in <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 9. When
<code>max.lag</code> is equal to <span class="math inline">\(0\)</span>,
this function can be see as a wrapper for the
<code>polynomial_block</code> function with order equal to <span class="math inline">\(1\)</span>. When <code>max.lag</code> is greater
or equal to <span class="math inline">\(1\)</span>, the
<code>regression_block</code> function is equivalent to the
superposition of several <code>polynomial_block</code> functions with
order equal to <span class="math inline">\(1\)</span>. Specifically, if
the linear predictor <span class="math inline">\(\lambda_t\)</span> is
associated with this block, we can describe its structure with the
following equations:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\lambda_t&amp;=\sum_{i=0}^{max.lag}X_{t-i}\theta_{i,t},\\
\theta_{i,t}&amp;=\theta_{i,t-1}+\omega_{i,t},\quad \forall i,\\
\omega_{0,t},...,\omega_{max.lag,t}&amp;\sim
\mathcal{N}_{max.lag+1}(0,W_t),\\
\theta_{0,1},...,
\theta_{max.lag,1}&amp;\sim \mathcal{N}_{max.lag+1}(a_1,R_1),
\end{aligned}
\end{equation}
\]</span> where <span class="math inline">\(W_t=Var[\theta_t|\mathcal{D}_{t-1}]\odot (1-D_t)
\oslash D_t+H_t\)</span>.</p>
<p>The usage of the <code>regression_block</code> function is quite
similar to that of the <code>polynomial_block</code> function, the only
differences being in the <code>max.lag</code> and <code>zero.fill</code>
arguments. The <code>max.lag</code> defines the maximum lag of the
variable <span class="math inline">\(X_t\)</span> that has effect on the
linear predictor. For example, if we define <code>max.lag</code> as
<span class="math inline">\(3\)</span>, we would be defining that <span class="math inline">\(X_t\)</span>, <span class="math inline">\(X_{t-1}\)</span>, <span class="math inline">\(X_{t-2}\)</span> and <span class="math inline">\(X_{t-3}\)</span> all have an effect on <span class="math inline">\(\lambda_t\)</span>, such that <span class="math inline">\(max.lag+1\)</span> latent variables are created,
each one representing the effect of a lagged value of <span class="math inline">\(X_t\)</span>.</p>
<p>Lastly, the <code>zero.fill</code> argument defines if the package
should take the value of <span class="math inline">\(X_t\)</span> to be
<span class="math inline">\(0\)</span> when <span class="math inline">\(t\)</span> is non-positive, i.e., if
<code>TRUE</code> (default), the package considers <span class="math inline">\(X_t=0\)</span>, for <span class="math inline">\(t=0,-1,...,-max.lag+1\)</span>. If
<code>zero.fill</code> is <code>FALSE</code>, then the user must provide
the values of <span class="math inline">\(X_t\)</span> as a vector of
size <span class="math inline">\(T+max.lag\)</span> (instead of <span class="math inline">\(T\)</span>), where <span class="math inline">\(T\)</span> is the length of the time series that
is being modeled, and the first <span class="math inline">\(max.lag\)</span> values of that vector will be
taken as <span class="math inline">\(X_{-max.lag+1},...,X_0\)</span>.</p>
<p>The usage of the remaining arguments is identical to that of the
<code>polynomial_block</code> function, and can also be inferred by the
previous equation.</p>
<p>Here we present the code for fitting the following model:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
Y_t|\theta_t &amp;\sim Poisson\left(\eta_t\right),\\
\ln(\eta_t) &amp;=\lambda_{t}=X_t\theta_t,\\
\theta_t&amp;=\theta_{t-1}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t),
\end{aligned}
\end{equation}
\]</span> where <span class="math inline">\(X_t\)</span> is a known
covariate and <span class="math inline">\(W_t\)</span> is specified
using a discount factor of <span class="math inline">\(0.95\)</span>.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">regression</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span>The_name_of_the_linear_predictor <span class="op">=</span> <span class="va">X</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span></span>
<span><span class="va">outcome</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"The_name_of_the_linear_predictor"</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">regression</span>, <span class="va">outcome</span><span class="op">)</span></span></code></pre></div>
<p><img src="structures_files/figure-html/unnamed-chunk-10-1.png" width="672"></p>
<p>The detailed theory behind the structure discussed in this section
can be found in chapters 6 and 9 from <span class="citation">West and
Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-harmonic-trend-models">A structure for harmonic trend models<a class="anchor" aria-label="anchor" href="#a-structure-for-harmonic-trend-models"></a>
</h2>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span></span>
<span>  <span class="va">...</span>,</span>
<span>  <span class="va">period</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var.Sazo"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1 <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">order</span> <span class="op">*</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>This function will creates a structural block based on <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 8, i.e., it creates a
latent vector <span class="math inline">\(\theta_t=(\theta_{1,t},\theta_{2,t},...,\theta_{2\times
order-1,t},\theta_{2\times order,t})'\)</span>, so that:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\begin{bmatrix}\theta_{2i -1,t}\\ \theta_{2i,t}\end{bmatrix} =
\begin{bmatrix}cos(iw) &amp; sin(iw)\\ -sin(iw) &amp;
cos(iw)\end{bmatrix}&amp;\begin{bmatrix}\theta_{2i -1,t-1}\\
\theta_{2i,t-1}\end{bmatrix}+\begin{bmatrix}\omega_{2i -1,t}\\
\omega_{2i,t}\end{bmatrix}, i=1,...,order\\
\theta_{1,1},...,\theta_{2 \times order,1}&amp;\sim \mathcal{N}_{2\times
order}(a_1,R_1),\\
\omega_{1,t},...,\omega_{2 \times order,t}&amp;\sim \mathcal{N}_{2\times
order}(0,W_t),\\
\end{aligned}
\end{equation}
\]</span> where <span class="math inline">\(W_t=Var[\theta_t|\mathcal{D}_{t-1}]\odot (1-D_t)
\oslash D_t+H_t\)</span> and <span class="math inline">\(w=\frac{2\pi}{period}\)</span>.</p>
<p>Notice that the user does not need to specify the matrix <span class="math inline">\(G_t\)</span>, since it is implicitly determined by
the order and the period of the harmonic block, being a block diagonal
matrix where each block is a rotation matrix for an angle multiple of
<span class="math inline">\(w\)</span>, such that, if
<code>period</code> is an integer, <span class="math inline">\(G_t^{period}=I\)</span>. Notice that, when
<code>period</code> is an integer, it represents the length of the
seasonal cycle. For instance, if we have a time series with monthly
observations and we believe this series to have an annual pattern, then
we would set the <code>period</code> for the harmonic block to be equal
to <span class="math inline">\(12\)</span> (the number of observations
until the cycle “resets”). For details about the order of the harmonic
block and the representation of seasonal patterns with Fourier Series,
see <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 8.</p>
<p>The natural usage of this block is for specifying harmonic trends for
the model, but it can also be used for explanatory variables with
seasonal effect on the linear predictor, for that, see the usage of the
<code>regression_block</code> and <code>polynomial_block</code>
functions.</p>
<p>Here we present a simply usage example for a harmonic block with
period <span class="math inline">\(12\)</span>:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  period <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.975</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Bellow we present a plot of a Poisson model with such structure:</p>
<p><img src="structures_files/figure-html/unnamed-chunk-14-1.png" width="672"></p>
<p>The detailed theory behind the structure discussed in this section
can be found in chapters 6, 8 and 9 from <span class="citation">West and
Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-autoregresive-models">A structure for autoregresive models<a class="anchor" aria-label="anchor" href="#a-structure-for-autoregresive-models"></a>
</h2>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/TF_block.html">TF_block</a></span><span class="op">(</span></span>
<span>  <span class="va">...</span>,</span>
<span>  <span class="va">order</span>,</span>
<span>  noise.var <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  noise.disc <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var.AR"</span>,</span>
<span>  AR.support <span class="op">=</span> <span class="st">"free"</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1 <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  h <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  D.coef <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h.coef <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H.coef <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1.coef <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  R1.coef <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.25</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  monitoring.coef <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">order</span><span class="op">)</span>,</span>
<span>  a1.pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1.pulse <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  D.pulse <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h.pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H.pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  monitoring.pulse <span class="op">=</span> <span class="cn">NA</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>This function creates a structural block based on <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 9, i.e., it creates a
latent state vector <span class="math inline">\(\theta_t\)</span>, an
autoregressive (AR) coefficient vector <span class="math inline">\(\phi_t=(\phi_{1,t},...,\phi_{order,
t})'\)</span> and a pulse coefficient vector <span class="math inline">\(\rho_t=(\rho_{1,t},...,\rho_{l,t})'\)</span>,
where <span class="math inline">\(l\)</span> is the number of pulses
(discussed later on) so that:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\theta_{t} &amp;=
\sum_{i=1}^{k}\phi_{i,t}\theta_{t-i}+\sum_{i=1}^{l}\rho_{i,t}X_{i,t}+\omega_{t},\\
\phi_{i,t}&amp;=\phi_{i,t-1}+\omega^{\text{coef}}_{i,t},\\
\rho_{i,t}&amp;=\rho_{i,t-1}+\omega_{i,t}^{pulse},\\
\omega_{t}&amp;\sim \mathcal{N}_1(h_t,W_t),\\
\omega_{t}^{\text{coef}}&amp;\sim
\mathcal{N}_k(h_t^{\text{coef}},W_t^{\text{coef}}),\\
\omega_{t}^{pulse}&amp;\sim \mathcal{N}_l(h_t^{pulse},W_t^{pulse}),\\
\theta_1&amp;\sim \mathcal{N}(a_1,R_1),\\
\phi_1&amp;\sim \mathcal{N}_k(a_1^{\text{coef}},R_1^{\text{coef}}),\\
\rho_1&amp;\sim \mathcal{N}_l(a_1^{pulse},R_1^{pulse}).
\end{aligned}
\end{equation}
\]</span> where:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
W_t&amp;=noise.var&amp;+&amp;\frac{(1-noise.disc)}{noise.disc}Var[\theta_t|\mathcal{D}_{t-1}]
&amp; &amp;  &amp; &amp; ,\\
W_t^{\text{coef}}&amp;=H_t^{\text{coef}}&amp;+&amp;Var[\phi_t|\mathcal{D}_{t-1}]
&amp;\odot&amp; (1-D_t^{\text{coef}}) &amp;\oslash&amp;
D_t^{\text{coef}},\\
W^{pulse}_t&amp;=H_t^{pulse}&amp;+&amp;Var[\rho_t|\mathcal{D}_{t-1}]
&amp;\odot&amp;(1-D_t^{pulse}) &amp;\oslash&amp;D_t^{pulse},
\end{aligned}
\end{equation}
\]</span> and <span class="math inline">\(X\)</span>, called pulse
matrix, is a known <span class="math inline">\(T \times l\)</span>
matrix.</p>
<p>Notice that the user does not need to specify the matrix <span class="math inline">\(G_t\)</span>, since it is implicitly determined by
the order of the Tranfer Function (TF) block and the equations above,
although, as the reader might have noticed, that evolution will always
be non-linear. Since the method used to fit models in this package
requires a linear evolution, we use the approach described in <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 13, to linearize the
previous evolution equation. For more details about the usage of
autoregressive models and transfer functions in the context of DLM’s,
see <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 9.</p>
<p>It is easy to understand the meaning of most arguments of the
<code>TF_block</code> function based on the previous equations, but some
explanation is still needed for the <code>AR.support</code> argument,
plus the arguments related with the so called <em>pulse</em>. We do
advise all users to consult the associated documentation for more
details (see <code><a href="../reference/TF_block.html">help(TF_block)</a></code> or the reference manual).</p>
<p>The <code>AR.support</code> is a character string, either
<code>"constrained"</code> or <code>"free"</code>. If
<code>AR.support</code> is <code>"constrained"</code>, then the AR
coefficients <span class="math inline">\(\phi_t\)</span> will be forced
to be on the interval <span class="math inline">\((-1,1)\)</span>,
otherwise, the coefficients will be unrestricted. Beware that, under no
restriction on the coefficients, there is no guarantee that the
estimated coefficients will imply in a stationary process, furthermore,
if the order of the TF block is greater than 1, then the restriction
imposed when <code>AR.support</code> is equal to
<code>"constrained"</code> does <strong>NOT</strong> guarantee that the
process will be stationary, as such, the user is not allowed to use
constrained parameters when the order of the block is greater than <span class="math inline">\(1\)</span>. To constrain <span class="math inline">\(\phi_t\)</span> to the interval <span class="math inline">\((-1,1)\)</span>, we apply the inverse Fisher
transformation, also known as the hyperbolic tangent function.</p>
<p>The pulse matrix <span class="math inline">\(X\)</span> is informed
through the argument <code>pulse</code>, with the dimension of <span class="math inline">\(\rho_t\)</span> being implied by the number of
columns in <span class="math inline">\(X\)</span>. It is important to
notice that the package expects that <span class="math inline">\(X\)</span> will inform the pulse value for each
time instance, interpreting each column as a distinct pulse with an
associated coordinate of <span class="math inline">\(\rho_t\)</span>.</p>
<p>Note that when the pulse is absent, <span class="math inline">\(X_t=0, \forall t\)</span>, the TF block is
equivalent to a autoregressive block.</p>
<p>Finally, we can summarize the usage of the <code>TF_block</code>
function as follows:</p>
<ul>
<li>
<code>a1</code>, <code>R1</code> are the parameter for the prior for
the accumulated effects <span class="math inline">\((\theta_1,...,\theta_{1-order})'\)</span>;</li>
<li>
<code>noise.var</code>, <code>noise.disc</code> and <code>h</code>
define the mean and variance of random fluctuations of <span class="math inline">\(\theta_t\)</span> through time;</li>
<li>
<code>a1.coef</code>, <code>R1.coef</code> are the parameter for the
prior for the coefficients <span class="math inline">\(\phi_1,
...,\phi_{order}\)</span>;</li>
<li>
<code>h.coef</code>, <code>H.coef</code> and <code>D.coef</code>
define the mean and variance of random fluctuations of <span class="math inline">\(\phi_t\)</span> through time;</li>
<li>
<code>a1.pulse</code>, <code>R1.pulse</code> are the parameter for
the prior for the pulse coefficient <span class="math inline">\(\rho_1\)</span>;</li>
<li>
<code>h.pulse</code>, <code>H.pulse</code> and <code>D.pulse</code>
define the mean and variance of random fluctuations of <span class="math inline">\(\rho_t\)</span> through time;</li>
<li>
<code>pulse</code> is the pulse matrix <span class="math inline">\(X\)</span>;</li>
<li>
<code>AR.support</code> defines the support for the AR coefficients
<span class="math inline">\(\phi_t\)</span>.</li>
</ul>
<p>Bellow we present the code for a simply <span class="math inline">\(AR(1)\)</span> block with <span class="math inline">\(W_t=0.1, \forall t\)</span>:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/TF_block.html">TF_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  noise.var <span class="op">=</span> <span class="fl">0.1</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Finally we present a plot of a Gamma model with known shape <span class="math inline">\(\alpha=1.5\)</span> and a AR structure for the
mean fitted with simulated data. We will refrain to show the code for
fitting the model itself, since we will discuss the tools for fitting in
a section of its own.</p>
<p><img src="structures_files/figure-html/unnamed-chunk-17-1.png" width="672"></p>
<div class="section level3">
<h3 id="some-comments-about-autoregressive-models-in-the-normal-family">Some comments about autoregressive models in the Normal family<a class="anchor" aria-label="anchor" href="#some-comments-about-autoregressive-models-in-the-normal-family"></a>
</h3>
<p>The user may have notice that the autoregressive block described
above is a little different from what is most common in the literature.
Specifically, we do not assume that the observed data itself (<span class="math inline">\(Y_t\)</span>) follows an autoregressive evolution,
but instead <span class="math inline">\(\theta_t\)</span> does. This
approach is a generalization of the usual autoregressive model, indeed,
if we have that <span class="math inline">\(Y_t\)</span> follows an
usual AR(k), such that:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
Y_t&amp;=\sum_{i=1}^{k}\phi_{i,t}Y_{t-1}+\epsilon_t,\\
\epsilon_t &amp;\sim \mathcal{N}_1(0,\sigma_t^2),
\end{aligned}
\end{equation}
\]</span> then, this model can also be written as:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
Y_t|\eta_t&amp;\sim \mathcal{N}_1(\eta_t,0),\\
\eta_t=\theta_t&amp;=\sum_{i=1}^{k}\phi_{i,t}\theta_{t-i}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t),
\end{aligned}
\end{equation}
\]</span> such that this model can be described using the
<code>TF_block</code> function.</p>
<p>More generally, if we have that <span class="math inline">\(Y_t|\eta_t \sim \mathcal{F}(\eta_t)\)</span>,
where <span class="math inline">\(\mathcal{F}\)</span> is a distribution
family contained in the exponential family and indexed by <span class="math inline">\(\eta_t\)</span>, then we have that:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
Y_t|\eta_t &amp;\sim \mathcal{F}(\eta_t),\\
g(\eta_t)=\theta_t&amp;=\sum_{i=1}^{k}\phi_{i,t}\theta_{t-i}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t).
\end{aligned}
\end{equation}
\]</span></p>
<p>It is important to note that there is some caveats about the first
specification (the usual one) and the more general one presented above.
As the reader will see further bellow, we offer, as a particular case,
the Normal distribution with both unknown mean and observational
variance, where we can specify predictive strucutre for
<strong>both</strong> the mean and the observational variance. In this
model, it does matter if the evolution error is associated with the
observation equation or the evolution equation (we cannot specify
predictive structure for former, but to the latter we can). For such
cases, we recommend the use of the <code>regression_block</code>
function instead of the <code>TF_block</code>.</p>
<p>Here we present an example of the specification of an AR(k) using the
<code>regression_block</code> function for a time series <span class="math inline">\(Y_t\)</span> of length <span class="math inline">\(T\)</span>:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">Y</span><span class="op">[</span><span class="op">-</span><span class="cn">T</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  max.lag <span class="op">=</span> <span class="va">k</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>In the Advanced Examples section we will provide a wide range of
examples, including ones with the aforementioned structures. In
particular, we will present the code for some usual (yet different from
what we discussed) forms of AR, including the following model:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
Y_t&amp;=\mu_t+\sum_{i=1}^{k}\phi_{i,t}(Y_{t-1}-\mu_{t-1})+\epsilon_t,\\
\epsilon_t &amp;\sim \mathcal{N}_1(0,\sigma_t^2),
\end{aligned}
\end{equation}
\]</span></p>
</div>
</div>
<div class="section level2">
<h2 id="a-structure-for-overdispersed-models">A structure for overdispersed models<a class="anchor" aria-label="anchor" href="#a-structure-for-overdispersed-models"></a>
</h2>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/noise_block.html">noise_block</a></span><span class="op">(</span><span class="va">...</span>, name <span class="op">=</span> <span class="st">"Noise"</span>, D <span class="op">=</span> <span class="fl">0.99</span>, R1 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>This function will creates a sequence of <strong>independent</strong>
latent variables <span class="math inline">\(\epsilon_1,...,\epsilon_t\)</span> based on the
discussions presented in <span class="citation">dos Santos et al. (<a href="#ref-ArtigoMultivar">2024</a>)</span>, such that:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
\epsilon_{t} &amp;\sim \mathcal{N}(0,\sigma_t^2),\\
\sigma_t^2&amp;=\frac{t-1}{t}D_t\sigma_{t-1}^2+\frac{1}{t}(1-D_t)\mathbb{E}[\epsilon_{t-1}^2|\mathcal{D}_{t-1}],\\
\sigma_1^2&amp;=R_1.
\end{aligned}
\end{equation}
\]</span></p>
<p>Notice that the user do not need to specify the matrix <span class="math inline">\(G_t\)</span>, since it is implicitly determined by
the equations above, such that <span class="math inline">\(G_t=0\)</span> for all <span class="math inline">\(t\)</span>.</p>
<p>It is easy to see the correspondence between most of the arguments of
the <code>noise_block</code> function and their respective meaning in
the block specification, while the remaining ones follow the same usage
seen in the previous block functions (see the
<code>polynomial_block</code> function).</p>
<p>As the user must have noticed, this block makes no sense on its own,
since it has barely any capability of learning patterns. But, we is
shown in the next subsection, structural blocks can be combined with
each other, such that the noise block would be only one of several other
structural blocks in a model.</p>
<p>To exemplify the utility of this structural block, let us assume we
want to model the following (simulated) time series of counts:</p>
<p><img src="structures_files/figure-html/unnamed-chunk-20-1.png" width="672"></p>
<p>Since the data is a counting, its natural to propose a Poisson model,
such that:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
Y_t|\theta_t &amp;\sim Poisson\left(\eta_t\right),\\
\ln(\eta_t) &amp;=\lambda_{t}=\theta_t,\\
\theta_t&amp;=\theta_{t-1}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t),
\end{aligned}
\end{equation}
\]</span></p>
<p>Bellow we present that model fitted using the <code>kDGLM</code>
package:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">level</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  rate <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">3</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.95</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">level</span>,</span>
<span>  <span class="st">"Model 1"</span> <span class="op">=</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"rate"</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.data</span>, lag <span class="op">=</span> <span class="fl">1</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="structures_files/figure-html/unnamed-chunk-21-1.png" width="672"></p>
<p>Notice that the data at the middle of the observed period is
overdispersed, such that a Poisson model cannot properly address the
uncertainty. One could proposed the usage of a Normal model which,
indeed, could capture the uncertainty in the middle, but notice that the
data at the beginning and at the end of the series has very low values,
such that a Normal model would be inappropriate. In such scenario, a
better approach would be to add an noise component to the linear
predictor, such that it can capture the overdispersion:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">level</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">3</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.95</span></span>
<span><span class="op">)</span></span>
<span><span class="va">noise</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/noise_block.html">noise_block</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">level</span>, <span class="va">noise</span>,</span>
<span>  <span class="st">"Model 2"</span> <span class="op">=</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"mu"</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.data</span>, lag <span class="op">=</span> <span class="fl">1</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="structures_files/figure-html/unnamed-chunk-22-1.png" width="672"></p>
<p>It is relevant to point out that the choice of <code>R1</code> can
affect the final fit, as such, we highly recommend the user to perform a
sensibility analysis to help specify the value of <code>R1</code>.</p>
<p>Lastly, as we will see latter on, the noise block can also be useful
to model the dependency between multiple time series.</p>
<p>For a more detailed discussion of this type of blocks, see <span class="citation">dos Santos et al. (<a href="#ref-ArtigoMultivar">2024</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="handling-multiple-structural-blocks">Handling multiple structural blocks<a class="anchor" aria-label="anchor" href="#handling-multiple-structural-blocks"></a>
</h2>
<p>n the previous subsections, we discussed how to define the structure
of a model using the functions <code>polynomial_block</code>,
<code>regression_block</code>, <code>harmonic_block</code>,
<code>TF_block</code> and <code>noise_block</code>. Each of these
functions results in a single structural block. Generally, the user will
want to mix multiple types of structures, each one being responsible to
explain part of the outcome <span class="math inline">\(Y_t\)</span>.
For this task, we introduce an operator designed to combine structural
blocks by superposition principle <span class="citation">(see <a href="#ref-WestHarr-DLM">West and Harrison, 1997, sec. 6.2</a>)</span>,
as follows.</p>
<p>Consider the scenario where one wishes to superimpose <span class="math inline">\(p\)</span> structural blocks; for instance: trend,
seasonal and regression components (<span class="math inline">\(p=3\)</span>). A general overlaid structure is
given by the following specifications:</p>
<p><span class="math display">\[
\begin{aligned}
\vec{\theta}_t&amp;=\begin{bmatrix}\vec{\theta}_t^1\\ \vdots\\
\vec{\theta}_t^n\end{bmatrix}, &amp;
F_t&amp;=\begin{bmatrix}F_t^1 \\
\vdots \\
F_t^p\end{bmatrix},\\
G_t&amp;=diag\{G_t^{1},...,G_t^{p}\},&amp;
W_t&amp;=diag\{W_t^{1},...,W_t^{p}\},
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(diag\{M^1,...,M^{p}\}\)</span>
represents a block diagonal matrix such that its diagonal is composed of
<span class="math inline">\(M^1,...,M^{p}\)</span>; <span class="math inline">\(\theta_t\)</span> is the vector obtained by the
concatenation of the vectors <span class="math inline">\(\vec{\theta}_t^1,..., \vec{\theta}_t^p\)</span>
corresponding to each structural block; and <span class="math inline">\(F_t\)</span> is obtained as follows: if a single
linear predictor is considered in the model, <span class="math inline">\(F_t\)</span> is a line vector concatenating
$F_t^1,…, F_t^p <span class="math inline">\(. For the case of several
predictors (\)</span>k&gt;1$, which will be seen in the next section),
the design matrix associated to structural block <span class="math inline">\(i\)</span>, <span class="math inline">\(F_t^i\)</span>, has dimension $n_i k $ and <span class="math inline">\(F_t\)</span> is a <span class="math inline">\(n
\times k\)</span> matrix, obtained by the row-wise concatenation of the
matrices <span class="math inline">\(F_t^1,..., F_t^p\)</span>, where
<span class="math inline">\(n=\sum_{i=1}^p n_i\)</span>.</p>
<p>In this scenario, to facilitate the specification of such model, we
could create one structural block for each <span class="math inline">\(\vec{\theta}_t^i\)</span>, <span class="math inline">\(F_t^{i}\)</span>, <span class="math inline">\(G_t^{i}\)</span> and <span class="math inline">\(W_t^{i}\)</span>, <span class="math inline">\(i=1,...p\)</span>, and then “combine” all blocks
together. The <strong>kDGLM</strong> package allows this operation
through the function <code>block_superpos</code> or, equivalently,
through the <code>+</code> operator:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">block_1</span> <span class="op">&lt;-</span> <span class="va">...</span></span>
<span><span class="va">.</span></span>
<span><span class="va">.</span></span>
<span><span class="va">.</span></span>
<span><span class="va">block_n</span> <span class="op">&lt;-</span> <span class="va">...</span></span>
<span></span>
<span><span class="va">complete_structure</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/block_superpos.html">block_superpos</a></span><span class="op">(</span><span class="va">block_1</span>, <span class="va">...</span>, <span class="va">block_n</span><span class="op">)</span></span>
<span><span class="co"># or</span></span>
<span><span class="va">complete_structure</span> <span class="op">&lt;-</span> <span class="va">block_1</span> <span class="op">+</span> <span class="va">...</span> <span class="op">+</span> <span class="va">block_n</span></span></code></pre></div>
<p>For a very high number <span class="math inline">\(p\)</span> of
structural blocks, the use of <code>block_superpos</code> is slightly
faster. To demonstrate the usage of the <code>+</code> operator, suppose
we would like to create a model using four of the structures presented
previously (a polynomial trend, a dynamic regression, a harmonic trend
and an AR model). We could do so with the following code:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">poly_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, name <span class="op">=</span> <span class="st">"Poly"</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span></span>
<span><span class="va">regr_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="va">X</span>, name <span class="op">=</span> <span class="st">"Regr"</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span></span>
<span><span class="va">harm_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, name <span class="op">=</span> <span class="st">"Harm"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">AR_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/TF_block.html">TF_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span>, noise.var <span class="op">=</span> <span class="fl">0.1</span>, name <span class="op">=</span> <span class="st">"AR"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">complete_block</span> <span class="op">&lt;-</span> <span class="va">poly_subblock</span> <span class="op">+</span> <span class="va">regr_subblock</span> <span class="op">+</span> <span class="va">harm_subblock</span> <span class="op">+</span> <span class="va">AR_subblock</span></span></code></pre></div>
<p>In the multiple regression context, that is, if more than one
regressor should be included in a predictor, the user must specify
different regression sub blocks, one for each regressor, and apply the
superposition principle to these blocks. Thus, in the previous code
lines, <code>X</code> is a vector with <span class="math inline">\(T\)</span> observations of a regressor <span class="math inline">\(X_t\)</span>, already defined in an
<strong>R</strong> object in the current environment and cannot be a
matrix of covariates. Ideally, the user should also provide each block
with a name to help identify them after the model is fitted, but, if the
user does not provide a name, the block will have the default name for
that type of block. If different blocks have the same name, an index
will be automatically added to the variables with conflicting labels
based on the order that the blocks were combined. Note that the
automatic naming might make the analysis of the fitted model confusing,
specially when dealing with a large number of latent states. With that
in mind, we <strong>strongly</strong> recommend the users to specify an
intuitive name for each structural block.</p>
<p>When integrating multiple blocks within a model, it’s crucial to
understand how their associated design matrices, denoted as <span class="math inline">\(F_t^{i}\)</span> for each block, are combined.
These matrices are concatenated vertically, one below the other.
Consequently, since the predictor vector <span class="math inline">\(\vec{\lambda}_t\)</span> is calculated as <span class="math inline">\(F_{t}'\vec{\theta}_t\)</span>, the influence
of each block on <span class="math inline">\(\vec{\lambda}_t\)</span> is
cumulative. In our previous code example, we introduced a linear
predictor named <code>eta</code>. In this context, the operations
performed in lines <code>1</code>, <code>5</code>, and <code>7</code>
(corresponding to <code>polynomial_block</code>,
<code>regression_block</code>, and <code>TF_block</code>, respectively),
are represented as <span class="math inline">\(eta_t=1 \times
\theta_{1,t}^{i},i=1,3,4\)</span>; while in line <code>3</code>
(corresponding to <code>regression_block</code>), the operation is <span class="math inline">\(eta_t=X_t \times \theta_{1,t}^{2}\)</span>. It’s
important to note that each block initially defines <code>eta</code>
independently. However, when these blocks are combined, their respective
equations are merged. As a result, the complete structure in line
<code>9</code> can be expressed as:</p>
<p><span class="math display">\[
eta_t= 1 \times \theta_{1,t}^{1} + X_t \times \theta_{1,t}^{2} + 1
\times \theta_{1,t}^{3} + 1 \times \theta_{1,t}^{4}
\]</span></p>
<p>This expression illustrates how the contributions from each
individual block are aggregated to form the final model. This
methodology allows for the flexible construction of complex models by
combining simpler components, each contributing to explain a particular
facet of the process <span class="math inline">\(\{Y_t\}_{t=1}^T\)</span>.</p>
</div>
<div class="section level2">
<h2 id="handling-multiple-linear-predictors">Handling multiple linear predictors<a class="anchor" aria-label="anchor" href="#handling-multiple-linear-predictors"></a>
</h2>
<p>As the user may have noticed, more then one argument can be passed in
the <code>...</code> argument. Indeed, if the user does so, several
linear predictors will be created in the same block (one for each unique
name), all of which are affected by the associated latent state. For
instance, take the following code:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># Common factor</span></span></code></pre></div>
<p>The code above creates <span class="math inline">\(3\)</span> linear
predictors <span class="math inline">\(\lambda_{1,t}\)</span>,<span class="math inline">\(\lambda_{2,t}\)</span> and <span class="math inline">\(\lambda_{3,t}\)</span> and a design matrix <span class="math inline">\(F_t=(1,1,1)'\)</span>, such that:</p>
<p><span class="math display">\[
\begin{aligned}
\lambda_{1,t}&amp;=1 \times \theta_{t}\\
\lambda_{2,t}&amp;=1 \times \theta_{t}\\
\lambda_{3,t}&amp;=1 \times \theta_{t}
\end{aligned}
\]</span></p>
<p>Note that the latent state <span class="math inline">\(\theta_{t}\)</span> is the same for all linear
predictors <span class="math inline">\(\lambda_{i,t}\)</span>, i.e.,
<span class="math inline">\(\theta_{t}\)</span> is a shared effect among
those linear predictors which could be used to induce association among
predictors. The specification of independent effects to each linear
predictor can be done by using different blocks to each latent
state:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_1</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_2</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># theta_3</span></span></code></pre></div>
<p>When the name of a linear predictor is missing from a particular
block, i.e., the name of a linear predictor was passed as an argument in
one block, but is absent in another, it is understood that particular
block has no effect on the linear predictor that is absent, such that
the previous code would be equivalent to:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Longer version of the previous code for the sake of clarity.</span></span>
<span><span class="co"># In general, when a block does not affect a particular linear predictor, that linear predictor should be ommited when creating the block.</span></span>
<span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">0</span>, lambda3 <span class="op">=</span> <span class="fl">0</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_1</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">0</span>, lambda2 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="fl">0</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_2</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">0</span>, lambda2 <span class="op">=</span> <span class="fl">0</span>, lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># theta_3</span></span></code></pre></div>
<p>As discussed in the end of Subsection <a href="structures.html#handling-multiple-structural-blocks">Handling
multiple structural blocks</a>, the effect of each block over the linear
predictors will be added to each other. As such both codes will create
<span class="math inline">\(3\)</span> linear predictors, such that:</p>
<p><span class="math display">\[
\begin{aligned}
\lambda_{1,t}&amp;=1 \times \theta_{1,t} + 0 \times \theta_{2,t} + 0
\times \theta_{3,t}=\theta_{1,t}\\
\lambda_{2,t}&amp;=0 \times \theta_{1,t} + 1 \times \theta_{2,t} + 0
\times \theta_{3,t}=\theta_{2,t}\\
\lambda_{3,t}&amp;=0 \times \theta_{1,t} + 0 \times \theta_{2,t} + 1
\times \theta_{3,t}=\theta_{3,t}
\end{aligned}
\]</span></p>
<p>Remind the syntax presented in the first illustration of the current
section, which guides the creation of common factors among predictors.
One can use multiple blocks in the same structure to define linear
predictors that share some (but not all) of their components:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_1</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_2</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_3</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># theta_4: Common factor</span></span></code></pre></div>
<p>representing the following structure:</p>
<p><span class="math display">\[
\begin{aligned}
\lambda_{1,t}&amp;=\theta_{1,t}+\theta_{4,t}\\
\lambda_{2,t}&amp;=\theta_{2,t}+\theta_{4,t}\\
\lambda_{3,t}&amp;=\theta_{3,t}+\theta_{4,t}\\
\end{aligned}
\]</span></p>
<p>The examples above all have very basic structures, so as to not
overwhelm the reader with overly intricate models. Still, the
<strong>kDGLM</strong> package is not limited to in any way by the
inclusion of multiple linear predictors, such that any structure one may
use with a single predictor can also be used with multiple linear
predictors. For example, we could have a model with <span class="math inline">\(3\)</span> linear predictors, each one having a
mixture of shared components and exclusive components:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#### Global level with linear growth ####</span></span>
<span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span>, order <span class="op">=</span> <span class="fl">2</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="co">#### Local variables for lambda1 ####</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="va">X1</span>, max.lag <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, D <span class="op">=</span> <span class="fl">0.98</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="co">#### Local variables for lambda2 ####</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/TF_block.html">TF_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span>, pulse <span class="op">=</span> <span class="va">X2</span>, order <span class="op">=</span> <span class="fl">1</span>, noise.disc <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span>, period <span class="op">=</span> <span class="fl">12</span>, D <span class="op">=</span> <span class="fl">0.98</span>, order <span class="op">=</span> <span class="fl">2</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="co">#### Local variables for lambda3 ####</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/TF_block.html">TF_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">2</span>, noise.disc <span class="op">=</span> <span class="fl">0.9</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="va">X3</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span></code></pre></div>
<p>Now we focus on the replication of structural blocks, for which we
apply <code>block_mult</code> function and the associated operator
<code>*</code>. This function allows the user to create multiple blocks
with identical structure, but each one being associated with a different
linear predictor. The usage of this function is as simple as:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">base.block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta <span class="op">=</span> <span class="fl">1</span>, name <span class="op">=</span> <span class="st">"Poly"</span>, D <span class="op">=</span> <span class="fl">0.95</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># final.block &lt;- block_mult(base.block, 4)</span></span>
<span><span class="co"># or</span></span>
<span><span class="co"># final.block &lt;- base.block * 4</span></span>
<span><span class="co"># or</span></span>
<span><span class="va">final.block</span> <span class="op">&lt;-</span> <span class="fl">4</span> <span class="op">*</span> <span class="va">base.block</span></span></code></pre></div>
<p>When replicating blocks, it is understood that each copy of the base
block is independent of each other (i.e., they have their own latent
states) and each block is associated with a different set of linear
predictors. The name of the linear predictors associated with each block
are taken to be the original names with an index:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">final.block</span><span class="op">$</span><span class="va">pred.names</span></span></code></pre></div>
<pre><code>[1] "eta.1" "eta.2" "eta.3" "eta.4"</code></pre>
<p>Naturally, the user might want to rename the linear predictors to a
more intuitive label. For such task, we provide the function:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">final.block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/block_rename.html">block_rename</a></span><span class="op">(</span><span class="va">final.block</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Matthew"</span>, <span class="st">"Mark"</span>, <span class="st">"Luke"</span>, <span class="st">"John"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">final.block</span><span class="op">$</span><span class="va">pred.names</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="handling-unknown-components-in-the-planning-matrix-f_t">Handling unknown components in the planning matrix <span class="math inline">\(F_t\)</span><a class="anchor" aria-label="anchor" href="#handling-unknown-components-in-the-planning-matrix-f_t"></a>
</h2>
<p>In some situations the user may want to fit a model such that:</p>
<p><span class="math display">\[
\begin{aligned}
\lambda_{t}=F_t'\theta_t=\cdots+\phi_t\theta_t +\cdots,
\end{aligned}
\]</span> in other words, it may be the case that the planning matrix
<span class="math inline">\(F_t\)</span> contains one or more unknown
components. This idea may be foreign when working with only one linear
predictor, but if our observational model has several predictors it
could make sense to have shared effects among predictors. Besides, this
construction is also natural when modeling multiple time series
simultaneously, such as when dealing with correlated outcomes or when
working with a compound regression. All those cases will be explored in
the Advanced Examples section of the vignette. For now, we will focus on
<strong>how</strong> to specify such structures, whatever their use may
be.</p>
<p>For simplicity, let us assume that we want to create a linear
predictor <span class="math inline">\(\lambda_t\)</span> such that <span class="math inline">\(\lambda_{t}=\phi_t\theta_t\)</span>. Then the
first step would be to create a linear predictor associated with <span class="math inline">\(\phi_t\)</span> (which we will call
<code>phi</code>, although the user may call it whatever it pleases the
user):</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">phi_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>phi <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>Notice that we are creating a linear predictor <span class="math inline">\(\phi_t\)</span> and a latent state <span class="math inline">\(\tilde{\theta}_t\)</span> such that <span class="math inline">\(\phi_t=1\times \tilde{\theta}_t\)</span>. Also, it
is important to note that the structure for <span class="math inline">\(\phi_t\)</span> could be any other structural
block (harmonic, regression, auto regression, etc.).</p>
<p>Now we can create a structural block for <span class="math inline">\(\theta_t\)</span>:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">theta_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"phi"</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>The code above creates a linear predictor <span class="math inline">\(\lambda_t\)</span> and a latent state <span class="math inline">\(\theta_t\)</span> such that <span class="math inline">\(\lambda_t=\phi_t \times \theta_t\)</span>. Notice
that the <code>...</code> argument of any structural block is used to
specify the planning matrix <span class="math inline">\(F_t\)</span>,
specifically, the user must provide a list of named values, where each
name indicates a linear predictor <span class="math inline">\(\lambda_t\)</span> and its associated value
represent the effect of <span class="math inline">\(\theta_{t}\)</span>
in this predictor. When the user pass a string in <code>...</code>, it
is implicitly that the component of <span class="math inline">\(F_t\)</span> associated with <span class="math inline">\(\theta_t\)</span> is unknown and modeled by the
linear predictor labelled as the passed string.</p>
<p>Lastly, as one could guess, it is possible to establish a chain of
components in <span class="math inline">\(F_t\)</span> in order to
create an even more complex structure. For instance, take the following
code:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta1 <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta2 <span class="op">=</span> <span class="st">"eta1"</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta3 <span class="op">=</span> <span class="st">"eta2"</span>, order <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>In the first line we create a linear predictor <span class="math inline">\(\eta_{1,t}\)</span> such that <span class="math inline">\(\eta_{1,t}=1 \times \theta_{1,t}\)</span>. In the
second line we create another linear predictor <span class="math inline">\(\eta_{2,t}\)</span> such that <span class="math inline">\(\eta_{2,t}=\eta_{1,t} \times
\theta_{2,t}=\theta_{1,t} \times \theta_{2,t}\)</span>. Then we create a
linear predictor <span class="math inline">\(\eta_{3,t}\)</span> such
that <span class="math inline">\(\eta_{3,t}=\eta_{2,t} \times
\theta_{3,t}=\theta_{1,t} \times \theta_{2,t} \times
\theta_{3,t}\)</span>.</p>
<p>To fit models with non-linear components in the <span class="math inline">\(F_t\)</span> and/or <span class="math inline">\(G_t\)</span> matrices, we use the Extended Kalman
Filter <span class="citation">(<a href="#ref-Kalman_filter_origins">Kalman, 1960</a>; <a href="#ref-WestHarr-DLM">West and Harrison, 1997</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="special-priors">Special priors<a class="anchor" aria-label="anchor" href="#special-priors"></a>
</h2>
<p>As discussed in Subsection <a href="structures.html#a-structure-for-polynomial-trend-models">A
structure for polynomial trend models</a>, the default prior for the
polynomial block—as well as for other blocks—assumes that the latent
states are independent with a mean <span class="math inline">\(0\)</span> and a variance of <span class="math inline">\(9\)</span>. Users have the flexibility to modify
this prior to any combination of mean vector and covariance matrix,
although the latent states of different blocks are always assumed to be
independent. It is important to note that this independence applies only
to the prior distribution; subsequent updates may induce correlations
between the latent states.</p>
<p>While this prior setup may be appropriate for a broad range of
applications, there may be instances where a user needs to apply a joint
prior for latent states across different blocks. For example, if a
similar model has previously been fitted to another dataset, an analyst
might wish to integrate information from this prior model into the new
fitting. To facilitate the specification of a joint prior for any set of
latent states, the <strong>kDGLM</strong> package offers the
<code>joint_prior</code> function:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/joint_prior.html">joint_prior</a></span><span class="op">(</span><span class="va">block</span>, var.index <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="va">block</span><span class="op">$</span><span class="va">n</span>, a1 <span class="op">=</span> <span class="va">block</span><span class="op">$</span><span class="va">a1</span><span class="op">[</span><span class="va">var.index</span><span class="op">]</span>, R1 <span class="op">=</span> <span class="va">block</span><span class="op">$</span><span class="va">R1</span><span class="op">[</span><span class="va">var.index</span>, <span class="va">var.index</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>The <code>joint_prior</code> function accepts a
<code>dlm_block</code> object and returns the same object with a
modified prior.</p>
<p>The <code>block</code> argument is a <code>dlm_block</code> object.
The syntax of this function is designed to facilitate the use of the
pipe operator (either <code>|&gt;</code> or <code>%&gt;%</code>),
allowing for seamless integration into piped sequences. For example:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span>, order <span class="op">=</span> <span class="fl">2</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/block_mult.html">block_mult</a></span><span class="op">(</span><span class="fl">5</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="../reference/joint_prior.html">joint_prior</a></span><span class="op">(</span>a1 <span class="op">=</span> <span class="va">prior.mean</span>, R1 <span class="op">=</span> <span class="va">prior.var</span><span class="op">)</span></span>
<span><span class="co"># assuming the objects prior.mean and prior.var are defined.</span></span></code></pre></div>
<p>The <code>var.index</code> argument is optional and indicates the
indexes of the latent states for which the prior distribution will be
modified.</p>
<p>The <code>a1</code> and <code>R1</code> arguments represent,
respectively, the mean vector and the covariance matrix for the latent
states that the user wishes to modify the prior for.</p>
<p>The user may also want to specify some special priors that impose a
certain structure for the data. For instance, the user may believe that
a certain set of latent state sum to <span class="math inline">\(0\)</span> or that there is a spacial structure to
them. This is specially relevant when modelling multiple time series,
for instance, lets say that we have <span class="math inline">\(r\)</span> series <span class="math inline">\(Y_{i,t}\)</span>, <span class="math inline">\(i=1,...r\)</span>, such that:</p>
<p><span class="math display">\[
\begin{aligned}    
Y_{i,t}|\eta_{i,t} &amp;\sim Poisson(\eta_{i,t})\\
\ln(\eta_{i,t})&amp;=\lambda_{it}=\mu_t+\alpha_{i,t},\\
\sum_{i=1}^{r} \alpha_{i,t}&amp;=0, \forall t.
\end{aligned}
\]</span></p>
<p>Similarly, one could want to specify a CAR prior <span class="citation">(<a href="#ref-banerjee2014hierarchical">Banerjee et
al., 2014</a>; <a href="#ref-AlexCar">Schmidt and Nobre,
2018</a>)</span> for the variables <span class="math inline">\(\alpha_1,...\alpha_r\)</span>, if the user
believes there is spacial autocorrelation.</p>
<p>For these scenarios, the <strong>kDGLM</strong> package provides
functions to facilitate the specification of special priors for
structural blocks, such as the <code>zero_sum_prior</code> and the
<code>CAR_prior</code>. Their general usage is analogous to the
<code>joint_prior</code> function. Details on these functions will be
omitted in this document for the sake of brevity. For comprehensive
usage instructions, please refer to the vignette or the associated
documentation.</p>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-banerjee2014hierarchical" class="csl-entry">
Banerjee, S., Carlin, B. P., and Gelfand, A. E. (2014). <em>Hierarchical
modeling and analysis for spatial data</em>. Chapman; Hall/CRC.
</div>
<div id="ref-ArtigoMultivar" class="csl-entry">
dos Santos, S. V., Junior, Alves, M. B., and Migon, H. S. (2024). An
efficient sequential approach for joint modelling of multiple time
series.
</div>
<div id="ref-Kalman_filter_origins" class="csl-entry">
Kalman, R. E. (1960). A new approach to linear filtering and prediction
problems. <em>Transactions of the ASME–Journal of Basic
Engineering</em>, <em>82</em>(Series D), 35–45.
</div>
<div id="ref-AlexCar" class="csl-entry">
Schmidt, A. M., and Nobre, W. S. (2018). <a href="https://doi.org/10.1002/9781118445112.stat08048" class="external-link">Conditional
autoregressive (CAR) model</a>. In <em>Wiley StatsRef: Statistics
reference online</em>, pages 1–11. John Wiley &amp; Sons, Ltd.
</div>
<div id="ref-WestHarr-DLM" class="csl-entry">
West, M., and Harrison, J. (1997). <em>Bayesian forecasting and dynamic
models (springer series in statistics)</em>. Hardcover; Springer-Verlag.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Silvaneo Vieira dos Santos Junior, Mariane Branco Alves, Hélio dos Santos Migon.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
