<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="kDGLM">
<title>Creation of model structures • kDGLM</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Creation of model structures">
<meta property="og:description" content="kDGLM">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">kDGLM</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.3</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/intro.html">Notation</a>
    <a class="dropdown-item" href="../articles/structures.html">Creation of model structures</a>
    <a class="dropdown-item" href="../articles/outcomes.html">Creation of model outcomes</a>
    <a class="dropdown-item" href="../articles/fitting.html">Fitting and analysing models</a>
    <a class="dropdown-item" href="../articles/example1.html">Applied example: Space-time model for hospital admissions from gastroenteritis</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/silvaneojunior/kDGLM/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Creation of model structures</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/silvaneojunior/kDGLM/blob/HEAD/vignettes/structures.Rmd" class="external-link"><code>vignettes/structures.Rmd</code></a></small>
      <div class="d-none name"><code>structures.Rmd</code></div>
    </div>

    
    
<p>In this vignette we will discuss the specification of the model
structure. We will consider the structure of a model as all the elements
that determine the relation between our linear predictor <span class="math inline">\(\lambda_t\)</span> and our latent states <span class="math inline">\(\theta_t\)</span> though time, i.e., we want the
define the following, highlighted equations from the model:</p>
<p><span class="math display">\[
\require{color}
\begin{align}
Y_t|\eta_t &amp;\sim \mathcal{F}\left(\eta_t\right),\\
g(\eta_t) &amp;= {\color{red}\lambda_{t}=F_t'\theta_t,}\\
{\color{red}\theta_t }&amp;{\color{red}=G_t\theta_{t-1}+\omega_t,}\\
{\color{red}\omega_t }&amp;{\color{red}\sim \mathcal{N}_n(h_t,W_t)}.
\end{align}
\]</span></p>
<p>Namely, we consider that the structure of a model consists of the
matrices <span class="math inline">\(F_t\)</span>, <span class="math inline">\(G_t\)</span>, <span class="math inline">\(h_t\)</span>, <span class="math inline">\(H_t\)</span> and <span class="math inline">\(D_t\)</span>.</p>
<p>Although we allow the user to manually define each entry of each of
those matrices (which we <strong>do not</strong> recommend), we also
offer tools to simplify this task. Let us start by presenting the basis
function for all structural blocks, the <code>polynomial_block</code>
function.</p>
<div class="section level2">
<h2 id="a-structure-for-polynomial-trend-models">A structure for polynomial trend models<a class="anchor" aria-label="anchor" href="#a-structure-for-polynomial-trend-models"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  <span class="va">...</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var.Poly"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">9</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="cn">TRUE</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>This function will create a structural block based on <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 7, i.e., it creates a
latent vector <span class="math inline">\(\theta_t=(\theta_{1,t},...,\theta_{k,t})'\)</span>,
where <span class="math inline">\(k\)</span> is the order of the
polynomial block, such that:</p>
<p><span class="math display">\[
\begin{align}
\theta_{i,t} &amp;= \theta_{i,t-1}+\theta_{i+1, t-1}+\omega_{i,t},
i=1,...,k-1\\
\theta_{k,t} &amp;= \theta_{k,t-1}+\omega_{k,t},\\
\theta_1&amp;\sim \mathcal{N}_k(a_1,R_1),\\
\omega_{1,t},...,\omega_{k,t}&amp;\sim \mathcal{N}_k(h_t,W_t),
\end{align}
\]</span> where <span class="math inline">\(W_t=Var[\theta_t|\mathcal{D}_{t-1}]\odot (1-D_t)
\oslash D_t+H_t\)</span>.</p>
<p>Notice that the user does not need to specify the matrix <span class="math inline">\(G_t\)</span>, since it is implicitly determined by
the equations above and the order of the polynomial block. Each type of
block will define it own matrix <span class="math inline">\(G_t\)</span>, as such, the user does not need to
worry about <span class="math inline">\(G_t\)</span>, except in very
specific circumstances, where one need a type of model that is not yet
implemented in the package.</p>
<p>It is easy to see the correspondence between most of the arguments of
the <code>polynomial_block</code> function and their respective meaning
in the block specification, remaining only to explain the use of the
<code>...</code>, <code>name</code> and <code>monitoring</code>
arguments. We do advise all users to consult the associated
documentation for more details (see <code><a href="../reference/polynomial_block.html">help(polynomial_block)</a></code>
or the reference manual).</p>
<p>The argument <code>...</code> is used to specify the matrix <span class="math inline">\(F_t\)</span>, specifically, the user must provide
a list of named values, whose name indicate a linear predictor <span class="math inline">\(\lambda_t\)</span> and its associated value
represents the effect of <span class="math inline">\(\theta_{1,t}\)</span> in this predictor (the other
latent states are assumed to have no effect on the linear predictors).
Naturally, if a linear predictor is not present in <code>...</code>, it
is understood that <span class="math inline">\(\theta_{1,t}\)</span>
have no effect whatsoever on that particular linear predictor. Such
specification of <span class="math inline">\(F_t\)</span> may seem
strange, but as the reader will see further bellow, this way of
specifying <span class="math inline">\(F_t\)</span> is very useful to
avoid confusion when dealing with multiple linear predictors.</p>
<p>It is important to emphasize that the dimesion of <span class="math inline">\(\theta_t\)</span> is implicitly determined by the
block structure, besides, <span class="math inline">\(\lambda_t\)</span>
is implicitly determined by <code>...</code>, since one linear predictor
will be created for each <strong>unique</strong> named value passed by
the user.</p>
<p>The argument <code>name</code> is optional and it is used to help the
user to identify each latent state after fitting the model,
specifically, each latent state will be called by its own name when
plotting or printing <span class="math inline">\(\theta_t\)</span>.</p>
<p>Lastly, the <code>monitoring</code> shall be explained latter, in the
section about monitoring and intervation.</p>
<p>Notice that the default values of each argument leads to a first
order polynomial block with no temporal dynamic, besides, the default
prior is such that <span class="math inline">\(\theta_{1,1} \sim
\mathcal{N}(0,9)\)</span> and <span class="math inline">\(\theta_{i,1}
\sim \mathcal{N}(0,1), i=2,...,k\)</span>.</p>
<p>To exemplify the usage of this function, let us assume that we have a
simple Normal model with known variance <span class="math inline">\(\sigma^2\)</span>, in which <span class="math inline">\(\eta\)</span> is the mean parameter and the link
function <span class="math inline">\(g\)</span> is such that <span class="math inline">\(g(\eta)=\eta\)</span>. Let us also assume that the
mean is constant over time and we have no explanatory variables, such
that our model can be written simple as:</p>
<p><span class="math display">\[
\begin{align}
Y_t|\theta_t &amp;\sim \mathcal{N}_1\left(\eta_t, \sigma^2\right),\\
\eta_t &amp;=\lambda_{t}=\theta_t,\\
\theta_t&amp;=\theta_{t-1}=\theta.
\end{align}
\]</span></p>
<p>In this case, we have that <span class="math inline">\(F_t=1\)</span>, <span class="math inline">\(G_t=1\)</span>, <span class="math inline">\(D_t=1\)</span>, <span class="math inline">\(h_t=0\)</span> and <span class="math inline">\(H_t=0\)</span>, for all <span class="math inline">\(t\)</span>. Assuming a prior distribution <span class="math inline">\(\mathcal{N}(0,9)\)</span> for <span class="math inline">\(\theta\)</span>, we can create such structure
using the following code:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Mean"</span>,</span>
<span><span class="op">)</span></span></code></pre></div>
<p>By setting <code>eta=1</code>, we specify that there is a linear
predictor called <em>eta</em>, and that <span class="math inline">\(eta
= 1 \times \theta\)</span>. By setting <code>order = 1</code>, we
specify that <span class="math inline">\(\theta_t\)</span> is a scalar
and that <span class="math inline">\(G_t=1\)</span>. We can omit the
values of <code>a1</code> , <code>R1</code>, <code>D</code>,
<code>h</code> and <code>H</code>, since the default values are equal to
the desired. We could also omit the argument <code>order</code>, since
the default is already <span class="math inline">\(1\)</span>, but we
chose to explicit define it so as to emphasize its usage.</p>
<p>Suppose now that we have a explanatory variable <span class="math inline">\(X\)</span> that we would like to introduce in our
model to help explain the behavior of <span class="math inline">\(\eta_t\)</span>. We could similarly define such
structure by creating an additional block such as:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="va">X</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var X"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>By setting <code>eta=X</code>, we specify that there is a linear
predictor called <em>eta</em>, and that <span class="math inline">\(eta
= X \times \theta\)</span>. If <span class="math inline">\(X=(X_1,...,X_T)'\)</span> is a vector, then we
would have <span class="math inline">\(F_t=X_t\)</span>, for each <span class="math inline">\(t\)</span>, such that <span class="math inline">\(\eta_t = X_t \times \theta_t\)</span>.</p>
<p>It is worth noting that there is a specific structural block designed
for regressions, called <code>regression_block</code>, but we also allow
any structural block to be used as a regression, allowing the user to
specify complex temporal dynamics for the effects of any covariate.</p>
<p>Until now, we only discussed the creation of static models, but the
inclusion of temporal dynamic is very straightforward, one must simply
specify the values of <code>H</code> to be greater than <span class="math inline">\(0\)</span> and/or the values of <code>D</code> to
be lesser than <span class="math inline">\(1\)</span>:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Mean"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.95</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Bellow we present a plot of two models fitted to the same data: one
with a static mean and another using a dynamic mean.</p>
<p><img src="structures_files/figure-html/unnamed-chunk-6-1.png" width="700"></p>
<p>The detailed theory behind the structure discussed in this section
can be found in chapters 6, 7 and 9 from <span class="citation">West and
Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-dynamic-regression-models">A structure for dynamic regression models<a class="anchor" aria-label="anchor" href="#a-structure-for-dynamic-regression-models"></a>
</h2>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span></span>
<span>  <span class="va">...</span>,</span>
<span>  max.lag <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  zero.fill <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var.Reg"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1 <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">max.lag</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The <code>regression_block</code> function creates a structural block
for a dynamic regression with covariate <span class="math inline">\(X_t\)</span>, as specified in <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 9. When
<code>max.lag</code> is equal to <span class="math inline">\(0\)</span>,
this function can be see as a wrapper for the
<code>polynomial_block</code> function with order equal to <span class="math inline">\(1\)</span>. When <code>max.lag</code> is greater
or equal to <span class="math inline">\(1\)</span>, the
<code>regression_block</code> function is equivalent to the
superposition of several <code>polynomial_block</code> functions with
order equal to <span class="math inline">\(1\)</span>. Specifically, if
the linear predictor <span class="math inline">\(\lambda_t\)</span> is
associated with this block, we can describe its structure with the
following equations:</p>
<p><span class="math display">\[
\begin{align}
\lambda_t&amp;=\sum_{i=0}^{max.lag}X_{t-i}\theta_{i,t},\\
\theta_{i,t}&amp;=\theta_{i,t-1}+\omega_{i,t},\quad \forall i,\\
\omega_{0,t},...,\omega_{max.lag,t}&amp;\sim
\mathcal{N}_{max.lag+1}(0,W_t),\\
\theta_{0,1},...,
\theta_{max.lag,1}&amp;\sim \mathcal{N}_{max.lag+1}(a_1,R_1),
\end{align}
\]</span> where <span class="math inline">\(W_t=Var[\theta_t|\mathcal{D}_{t-1}]\odot (1-D_t)
\oslash D_t+H_t\)</span>.</p>
<p>The usage of the <code>regression_block</code> function is quite
similar to that of the <code>polynomial_block</code> function, the only
differences being in the <code>max.lag</code> and <code>zero.fill</code>
arguments. The <code>max.lag</code> defines the maximum lag of the
variable <span class="math inline">\(X_t\)</span> that has effect on the
linear predictor. For example, if we define <code>max.lag</code> as
<span class="math inline">\(3\)</span>, we would be defining that <span class="math inline">\(X_t\)</span>, <span class="math inline">\(X_{t-1}\)</span>, <span class="math inline">\(X_{t-2}\)</span> and <span class="math inline">\(X_{t-3}\)</span> all have an effect on <span class="math inline">\(\lambda_t\)</span>, such that <span class="math inline">\(max.lag+1\)</span> latent variables are created,
each one representing the effect of a lagged value of <span class="math inline">\(X_t\)</span>.</p>
<p>Lastly, the <code>zero.fill</code> argument defines if the package
should take the value of <span class="math inline">\(X_t\)</span> to be
<span class="math inline">\(0\)</span> when <span class="math inline">\(t\)</span> is non-positive, i.e., if
<code>TRUE</code> (default), the package considers <span class="math inline">\(X_t=0\)</span>, for <span class="math inline">\(t=0,-1,...,-max.lag+1\)</span>. If
<code>zero.fill</code> is <code>FALSE</code>, then the user must provide
the values of <span class="math inline">\(X_t\)</span> as a vector of
size <span class="math inline">\(T+max.lag\)</span> (instead of <span class="math inline">\(T\)</span>), where <span class="math inline">\(T\)</span> is the length of the time series that
is being modeled, and the first <span class="math inline">\(max.lag\)</span> values of that vector will be
taken as <span class="math inline">\(X_{-max.lag+1},...,X_0\)</span>.</p>
<p>The usage of the remaining arguments is identical to that of the
<code>polynomial_block</code> function, and can also be inferred by the
previous equation. As such, we will only emphasize the usage of the
<code>...</code> argument.</p>
<p>The argument <code>...</code> is used to specify the matrix <span class="math inline">\(F_t\)</span>, specifically, the user must provide
a list of named values, whose name indicate a linear predictor <span class="math inline">\(\lambda_t\)</span>. The effect of <span class="math inline">\(X_t\)</span> in this predictor is represented by
<span class="math inline">\(\theta_{0,t},...,\theta_{max.lag,t}\)</span>, such
that <span class="math inline">\(\theta_{i,t}\)</span> represents the
effect of <span class="math inline">\(X_{t-i}\)</span> in <span class="math inline">\(\lambda_t\)</span> (i.e., the lagged effect of
order <span class="math inline">\(i\)</span>). It is easy to see that,
if <span class="math inline">\(X_t=x\)</span>, for all <span class="math inline">\(t\)</span> (in other words, if <span class="math inline">\(X_t\)</span> is constant), one <strong>should
not</strong> use <span class="math inline">\(max.lag\)</span> greater
then <span class="math inline">\(0\)</span> . Naturally, if a linear
predictor is not present in <code>...</code>, it is understood that
<span class="math inline">\(X_t\)</span> has no effect whatsoever on
that particular linear predictor. Such specification of <span class="math inline">\(F_t\)</span> may seem strange, but as the reader
will see further bellow, this way of specifying <span class="math inline">\(F_t\)</span> is very useful to avoid confusion
when dealing with multiple linear predictors.</p>
<p>Here we present the code for fitting the following model:</p>
<p><span class="math display">\[
\begin{align}
Y_t|\theta_t &amp;\sim Poisson\left(\eta_t\right),\\
\ln(\eta_t) &amp;=\lambda_{t}=X_t\theta_t,\\
\theta_t&amp;=\theta_{t-1}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t),
\end{align}
\]</span> where <span class="math inline">\(X_t\)</span> is a known
covariate and <span class="math inline">\(W_t\)</span> is specified
using a discount factor of <span class="math inline">\(0.95\)</span>.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">regression</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span>The_name_of_the_linear_predictor <span class="op">=</span> <span class="va">X</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span></span>
<span></span>
<span><span class="va">outcome</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"The_name_of_the_linear_predictor"</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">regression</span>, <span class="va">outcome</span><span class="op">)</span></span></code></pre></div>
<p><img src="structures_files/figure-html/unnamed-chunk-10-1.png" width="700"></p>
<p>The detailed theory behind the structure discussed in this section
can be found in chapters 6 and 9 from <span class="citation">West and
Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-harmonic-trend-models">A structure for harmonic trend models<a class="anchor" aria-label="anchor" href="#a-structure-for-harmonic-trend-models"></a>
</h2>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span></span>
<span>  <span class="va">...</span>,</span>
<span>  <span class="va">period</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var.Sazo"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1 <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">order</span> <span class="op">*</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>This function will creates a structural block based on <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 8, i.e., it creates a
latent vector <span class="math inline">\(\theta_t=(\theta_{1,t},\theta_{2,t},...,\theta_{2\times
order-1,t},\theta_{2\times order,t})'\)</span>, so that:</p>
<p><span class="math display">\[
\begin{bmatrix}\theta_{2i -1,t}\\ \theta_{2i,t}\end{bmatrix} =
\begin{bmatrix}cos(iw) &amp; sin(iw)\\ -sin(iw) &amp;
cos(iw)\end{bmatrix}\begin{bmatrix}\theta_{2i -1,t-1}\\
\theta_{2i,t-1}\end{bmatrix}+\begin{bmatrix}\omega_{2i -1,t}\\
\omega_{2i,t}\end{bmatrix}, i=1,...,order\\
\begin{align}
\theta_{1,1},...,\theta_{2 \times order,1}&amp;\sim \mathcal{N}_{2\times
order}(a_1,R_1),\\
\omega_{1,t},...,\omega_{2 \times order,t}&amp;\sim \mathcal{N}_{2\times
order}(0,W_t),\\
\end{align}
\]</span> where <span class="math inline">\(W_t=Var[\theta_t|\mathcal{D}_{t-1}]\odot (1-D_t)
\oslash D_t+H_t\)</span> and <span class="math inline">\(w=\frac{2\pi}{period}\)</span>.</p>
<p>Notice that the user does not need to specify the matrix <span class="math inline">\(G_t\)</span>, since it is implicitly determined by
the order and the period of the harmonic block, being a block diagonal
matrix where each block is a rotation matrix for an angle multiple of
<span class="math inline">\(w\)</span>, such that, if
<code>period</code> is an integer, <span class="math inline">\(G_t^{period}=I\)</span>. Notice that, when
<code>period</code> is an integer, it represents the length of the
seasonal cycle. For instance, if we have a time series with monthly
observations and we believe this series to have an annual pattern, then
we would set the <code>period</code> for the harmonic block to be equal
to 12 (the number of observations until the cycle “resets”). For details
about the order of the harmonic block and the representation of seasonal
patterns with Fourier Series, see <span class="citation">West and
Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 8.</p>
<p>Similar to the <code>polynomial_block</code> function, the argument
<code>...</code> is used to specify the matrix <span class="math inline">\(F_t\)</span>. The user must provide a list of
named values whose name indicate a linear predictor <span class="math inline">\(\lambda_t\)</span> and its associated value
represent the effect of <span class="math inline">\(\theta_{it}\)</span>, for odd <span class="math inline">\(i\)</span>, in this predictor (the other latent
states are assumed to have no effect on the linear predictors).
Naturally, if a linear predictor is not present in <code>...</code>, it
is understood that this block has no effect whatsoever on that
particular linear predictor.</p>
<p>The natural usage of this block is for specifying harmonic trends for
the model, but it can also be used for explanatory variables with
seasonal effect on the linear predictor, for that, see the usage of the
<code>regression_block</code> and <code>polynomial_block</code>
functions.</p>
<p>Here we present a simply usage example for a harmonic block with
period <span class="math inline">\(12\)</span>:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  period <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.975</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Bellow we present a plot of a Poisson model with such structure:</p>
<p><img src="structures_files/figure-html/unnamed-chunk-14-1.png" width="700"></p>
<p>The detailed theory behind the structure discussed in this section
can be found in chapters 6, 8 and 9 from <span class="citation">West and
Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>.</p>
</div>
<div class="section level2">
<h2 id="a-structure-for-autoregresive-models">A structure for autoregresive models<a class="anchor" aria-label="anchor" href="#a-structure-for-autoregresive-models"></a>
</h2>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/AR_block.html">AR_block</a></span><span class="op">(</span></span>
<span>  <span class="va">...</span>,</span>
<span>  <span class="va">order</span>,</span>
<span>  noise.var <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  noise.disc <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Var.AR"</span>,</span>
<span>  AR.support <span class="op">=</span> <span class="st">"free"</span>,</span>
<span>  a1 <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1 <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  h <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  monitoring <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  D.coef <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h.coef <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H.coef <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  a1.coef <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  R1.coef <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.25</span>, <span class="va">order</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  monitoring.coef <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">FALSE</span>, <span class="va">order</span><span class="op">)</span>,</span>
<span>  a1.pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  R1.pulse <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  D.pulse <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  h.pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  H.pulse <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  monitoring.pulse <span class="op">=</span> <span class="cn">NA</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>This function creates a structural block based on <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 9, i.e., it creates a
latent state vector <span class="math inline">\(\theta_t\)</span>, an
autoregressive (AR) coefficient vector <span class="math inline">\(\phi_t=(\phi_{1,t},...,\phi_{order,
t})'\)</span> and a pulse coefficient vector <span class="math inline">\(\rho_t=(\rho_{1,t},...,\rho_{l,t})'\)</span>,
where <span class="math inline">\(l\)</span> is the number of pulses
(discussed later on) so that:</p>
<p><span class="math display">\[
\begin{align}
\theta_{t} &amp;=
\sum_{i=1}^{k}\phi_{i,t}\theta_{t-i}+\sum_{i=1}^{l}\rho_{i,t}X_{i,t}+\omega_{t},\\
\phi_{i,t}&amp;=\phi_{i,t-1}+\omega^{\text{coef}}_{i,t},\\
\rho_{i,t}&amp;=\rho_{i,t-1}+\omega_{i,t}^{pulse},\\
\omega_{t}&amp;\sim \mathcal{N}_1(h_t,W_t),\\
\omega_{t}^{\text{coef}}&amp;\sim
\mathcal{N}_k(h_t^{\text{coef}},W_t^{\text{coef}}),\\
\omega_{t}^{pulse}&amp;\sim \mathcal{N}_l(h_t^{pulse},W_t^{pulse}),\\
\theta_1&amp;\sim \mathcal{N}(a_1,R_1),\\
\phi_1&amp;\sim \mathcal{N}_k(a_1^{\text{coef}},R_1^{\text{coef}}),\\
\rho_1&amp;\sim \mathcal{N}_l(a_1^{pulse},R_1^{pulse}).
\end{align}
\]</span> where:</p>
<p><span class="math display">\[
\begin{align}
W_t&amp;=noise.var&amp;+&amp;\frac{(1-noise.disc)}{noise.disc}Var[\theta_t|\mathcal{D}_{t-1}]
&amp; &amp;  &amp; &amp; ,\\
W_t^{\text{coef}}&amp;=H_t^{\text{coef}}&amp;+&amp;Var[\phi_t|\mathcal{D}_{t-1}]
&amp;\odot&amp; (1-D_t^{\text{coef}}) &amp;\oslash&amp;
D_t^{\text{coef}},\\
W^{pulse}_t&amp;=H_t^{pulse}&amp;+&amp;Var[\rho_t|\mathcal{D}_{t-1}]
&amp;\odot&amp;(1-D_t^{pulse}) &amp;\oslash&amp;D_t^{pulse},
\end{align}
\]</span> and <span class="math inline">\(X\)</span>, called pulse
matrix, is a known <span class="math inline">\(T \times l\)</span>
matrix.</p>
<p>Notice that the user does not need to specify the matrix <span class="math inline">\(G_t\)</span>, since it is implicitly determined by
the order of the AR block and the equations above, although, as the
reader might have noticed, that evolution will always be non-linear.
Since the method used to fit models in this package requires a linear
evolution, we use the approach described in <span class="citation">West
and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 13,
to linearize the previous evolution equation. For more details about the
usage of autoregressive models in the context of DLM’s, see <span class="citation">West and Harrison (<a href="#ref-WestHarr-DLM">1997</a>)</span>, chapter 9.</p>
<p>It is easy to understand the meaning of most arguments of the
<code>AR_block</code> function based on the previous equations, but some
explanation is still needed for the <code>...</code>, <code>name</code>
and <code>AR.support</code> arguments, plus the arguments related with
the so called <em>pulse</em>. We do advise all users to consult the
associated documentation for more details (see
<code><a href="../reference/AR_block.html">help(AR_block)</a></code> or the reference manual).</p>
<p>Similar to the <code>polynomial_block</code> function, the argument
<code>...</code> is used to specify the matrix <span class="math inline">\(F_t\)</span>. The user must provide a list of
named values, whose name indicate a linear predictor <span class="math inline">\(\lambda_t\)</span> and its associated value
represents the effect of <span class="math inline">\(\theta_{t}\)</span>
in this predictor (we assume that <span class="math inline">\(\phi_t\)</span> and <span class="math inline">\(\rho_t\)</span> have no effect on the linear
predictors). Naturally, if a linear predictor is not present in
<code>...</code>, it is understood that <span class="math inline">\(\theta_{t}\)</span> has no effect whatsoever on
that particular linear predictor.</p>
<p>Also, in the same fashion as the other structure functions, the
<code>name</code> argument is optional, providing an easy way to
identify each latent variable when plotting and summarizing a fitted
model.</p>
<p>The <code>AR.support</code> is a character string, either
<code>"constrained"</code> or <code>"free"</code>. If
<code>AR.support</code> is <code>"constrained"</code>, then the AR
coefficients <span class="math inline">\(\phi_t\)</span> will be forced
to be on the interval <span class="math inline">\((-1,1)\)</span>,
otherwise, the coefficients will be unrestricted. Beware that, under no
restriction on the coefficients, there is no guarantee that the
estimated coefficients will imply in a stationary process, furthermore,
if the order of the AR block is greater than 1, then the restriction
imposed when <code>AR.support</code> is equal to
<code>"constrained"</code> does <strong>NOT</strong> guarantee that the
process will be stationary, as such, the user is not allowed to use
constrained parameters when the order of the block is greater than <span class="math inline">\(1\)</span>. To constrain <span class="math inline">\(\phi_t\)</span> to the interval <span class="math inline">\((-1,1)\)</span>, we apply the inverse Fisher
transformation, also known as the hyperbolic tangent function.</p>
<p>The pulse matrix <span class="math inline">\(X\)</span> is informed
through the argument <code>pulse</code>, with the dimension of <span class="math inline">\(\rho_t\)</span> being implied by the number of
columns in <span class="math inline">\(X\)</span>. It is important to
notice that the package expects that <span class="math inline">\(X\)</span> will inform the pulse value for each
time instance, interpreting each column as a distinct pulse with an
associated coordinate of <span class="math inline">\(\rho_t\)</span>.</p>
<p>Finally, we can summarize the usage of the <code>AR_block</code>
function as follows:</p>
<ul>
<li>
<code>a1</code>, <code>R1</code> are the parameter for the prior for
the AR coefficient <span class="math inline">\((\theta_1,...,\theta_{1-order})'\)</span>;</li>
<li>
<code>noise.var</code>, <code>noise.disc</code> and <code>h</code>
define the mean and variance of random fluctuations of <span class="math inline">\(\theta_t\)</span> through time;</li>
<li>
<code>a1.coef</code>, <code>R1.coef</code> are the parameter for the
prior for the coefficients <span class="math inline">\(\phi_1,
...,\phi_{order}\)</span>;</li>
<li>
<code>h.coef</code>, <code>H.coef</code> and <code>D.coef</code>
define the mean and variance of random fluctuations of <span class="math inline">\(\phi_t\)</span> through time;</li>
<li>
<code>a1.pulse</code>, <code>R1.pulse</code> are the parameter for
the prior for the pulse coefficient <span class="math inline">\(\rho_1\)</span>;</li>
<li>
<code>h.pulse</code>, <code>H.pulse</code> and <code>D.pulse</code>
define the mean and variance of random fluctuations of <span class="math inline">\(\rho_t\)</span> through time;</li>
<li>
<code>pulse</code> is the pulse matrix <span class="math inline">\(X\)</span>;</li>
<li>
<code>AR.support</code> defines the support for the AR coefficients
<span class="math inline">\(\phi_t\)</span>.</li>
</ul>
<p>Bellow we present the code for a simply <span class="math inline">\(AR(1)\)</span> block with <span class="math inline">\(W_t=0.1, \forall t\)</span>:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/AR_block.html">AR_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  noise.var <span class="op">=</span> <span class="fl">0.1</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Finally we present a plot of a Gamma model with known shape <span class="math inline">\(\alpha=1.5\)</span> and a AR structure for the
mean fitted with simulated data. We will refrain to show the code for
fitting the model itself, since we will discuss the tools for fitting in
a section of its own.</p>
<p><img src="structures_files/figure-html/unnamed-chunk-17-1.png" width="1536"></p>
<div class="section level3">
<h3 id="some-comments-about-autoregressive-models-in-the-normal-family">Some comments about autoregressive models in the Normal family<a class="anchor" aria-label="anchor" href="#some-comments-about-autoregressive-models-in-the-normal-family"></a>
</h3>
<p>The user may have notice that the autoregressive block described
above is a little different from what is most common in the literature.
Specifically, we do not assume that the observed data itself (<span class="math inline">\(Y_t\)</span>) follows an autoregressive evolution,
but instead <span class="math inline">\(\theta_t\)</span> does. This
approach is a generalization of the usual autoregressive model, indeed,
if we have that <span class="math inline">\(Y_t\)</span> follows an
usual AR(k), such that:</p>
<p><span class="math display">\[
\begin{align}
Y_t&amp;=\sum_{i=1}^{k}\phi_{i,t}Y_{t-1}+\epsilon_t,\\
\epsilon_t &amp;\sim \mathcal{N}_1(0,\sigma_t^2),
\end{align}
\]</span> then, this model can also be written as:</p>
<p><span class="math display">\[
\begin{align}
Y_t|\eta_t&amp;\sim \mathcal{N}_1(\eta_t,0),\\
\eta_t=\theta_t&amp;=\sum_{i=1}^{k}\phi_{i,t}\theta_{t-i}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t),
\end{align}
\]</span> such that this model can be described using the
<code>AR_block</code> function.</p>
<p>More generally, if we have that <span class="math inline">\(Y_t|\eta_t \sim \mathcal{F}(\eta_t)\)</span>,
where <span class="math inline">\(\mathcal{F}\)</span> is a distribution
family contained in the exponential family and indexed by <span class="math inline">\(\eta_t\)</span>, then we have that:</p>
<p><span class="math display">\[
\begin{align}
Y_t|\eta_t &amp;\sim \mathcal{F}(\eta_t),\\
g(\eta_t)=\theta_t&amp;=\sum_{i=1}^{k}\phi_{i,t}\theta_{t-i}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t).
\end{align}
\]</span></p>
<p>It is important to note that there is some caveats about the first
specification (the usual one) and the more general one presented above.
As the reader will see further bellow, we offer, as a particular case,
the Normal distribution with both unknown mean and observational
variance, where we can specify predictive strucutre for
<strong>both</strong> the mean and the observational variance. In this
model, it does matter if the evolution error is associated with the
observation equation or the evolution equation (we cannot specify
predictive structure for former, but to the latter we can). For such
cases, we recommend the use of the <code>regression_block</code>
function instead of the <code>AR_block</code>.</p>
<p>Here we present an example of the specification of an AR(k) using the
<code>regression_block</code> function for a time series <span class="math inline">\(Y_t\)</span> of length <span class="math inline">\(T\)</span>:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">Y</span><span class="op">[</span><span class="op">-</span><span class="cn">T</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  max.lag <span class="op">=</span> <span class="va">k</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>In the Advanced Examples section we will provide a wide range of
examples, including ones with the aforementioned structures. In
particular, we will present the code for some usual (yet different from
what we discussed) forms of AR, including the following model:</p>
<p><span class="math display">\[
\begin{align}
Y_t&amp;=\mu_t+\sum_{i=1}^{k}\phi_{i,t}(Y_{t-1}-\mu_{t-1})+\epsilon_t,\\
\epsilon_t &amp;\sim \mathcal{N}_1(0,\sigma_t^2),
\end{align}
\]</span></p>
</div>
</div>
<div class="section level2">
<h2 id="a-structure-for-overdispersed-models">A structure for overdispersed models<a class="anchor" aria-label="anchor" href="#a-structure-for-overdispersed-models"></a>
</h2>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/noise_block.html">noise_block</a></span><span class="op">(</span><span class="va">...</span>, name <span class="op">=</span> <span class="st">"Noise"</span>, D <span class="op">=</span> <span class="fl">0.99</span>, R1 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>This function will creates a sequence of <strong>independent</strong>
latent variables <span class="math inline">\(\epsilon_1,...,\epsilon_t\)</span> such that:</p>
<p><span class="math display">\[
\begin{align}
\epsilon_{t} &amp;\sim \mathcal{N}(0,\sigma_t^2),\\
\sigma_t^2&amp;=\frac{t-1}{t}D_t\sigma_{t-1}^2+\frac{1}{t}(1-D_t)\mathbb{E}[\epsilon_{t-1}^2|\mathcal{D}_{t-1}],\\
\sigma_1^2&amp;=R_1.
\end{align}
\]</span></p>
<p>Notice that the user do not need to specify the matrix <span class="math inline">\(G_t\)</span>, since it is implicitly determined by
the equations above, such that <span class="math inline">\(G_t=0\)</span> for all <span class="math inline">\(t\)</span>.</p>
<p>It is easy to see the correspondence between most of the arguments of
the <code>noise_block</code> function and their respective meaning in
the block specification, while the remaining ones follow the same usage
seen in the previous block functions (see the
<code>polynomial_block</code> function). Here we will only emphasize the
usage of the <code>...</code> argument.</p>
<p>The argument <code>...</code> is used to specify the matrix <span class="math inline">\(F_t\)</span>, specifically, the user must provide
a list of named values, whose name indicate a linear predictor <span class="math inline">\(\lambda_t\)</span> and its associated value
represent the effect of <span class="math inline">\(\epsilon_{t}\)</span> in this predictor.
Naturally, if a linear predictor is not present in <code>...</code>, it
is understood that <span class="math inline">\(\epsilon_{t}\)</span>
have no effect whatsoever on that particular linear predictor. Such
specification of <span class="math inline">\(F_t\)</span> may seem
strange, but as the reader will see further bellow, this way of
specifying <span class="math inline">\(F_t\)</span> is very useful to
avoid confusion when dealing with multiple linear predictors.</p>
<p>It is important to emphasize that the dimension of <span class="math inline">\(\lambda_t\)</span> is implicitly determined by
<code>...</code>, since one linear predictor will be created for each
<strong>unique</strong> named value passed by the user.</p>
<p>As the user must have noticed, this block makes no sense on its own,
since it has barely any capability of learning patterns. But, we is
shown in the next subsection, structural blocks can be combined with
each other, such that the noise block would be only one of several other
structural blocks in a model.</p>
<p>To exemplify the utility of this structural block, let us assume we
want to model the following (simulated) time series of counts:</p>
<p><img src="structures_files/figure-html/unnamed-chunk-20-1.png" width="700"></p>
<p>Since the data is a counting, its natural to propose a Poisson model,
such that:</p>
<p><span class="math display">\[
\begin{align}
Y_t|\theta_t &amp;\sim Poisson\left(\eta_t\right),\\
\ln(\eta_t) &amp;=\lambda_{t}=\theta_t,\\
\theta_t&amp;=\theta_{t-1}+\omega_t,\\
\omega_t &amp;\sim \mathcal{N}_1(0,W_t),
\end{align}
\]</span></p>
<p>Bellow we present that model fitted using the <code>kDGLM</code>
package:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">level</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  rate <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">3</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.95</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">level</span>,</span>
<span>  <span class="st">"Model 1"</span> <span class="op">=</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"rate"</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.data</span>, lag <span class="op">=</span> <span class="fl">1</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="structures_files/figure-html/unnamed-chunk-21-1.png" width="700"></p>
<p>Notice that the data at the middle of the observed period is
overdispersed, such that a Poisson model cannot properly address the
uncertainty. One could proposed the usage of a Normal model which,
indeed, could capture the uncertainty in the middle, but notice that the
data at the beginning and at the end of the series has very low values,
such that a Normal model would be inappropriate. In such scenario, a
better approach would be to add an noise component to the linear
predictor, such that it can capture the overdispersion:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">level</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">3</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.95</span></span>
<span><span class="op">)</span></span>
<span><span class="va">noise</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/noise_block.html">noise_block</a></span><span class="op">(</span></span>
<span>  mu <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">fitted.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fit_model.html">fit_model</a></span><span class="op">(</span><span class="va">level</span>, <span class="va">noise</span>,</span>
<span>  <span class="st">"Model 2"</span> <span class="op">=</span> <span class="fu"><a href="../reference/Poisson.html">Poisson</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"mu"</span>, data <span class="op">=</span> <span class="va">data</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">fitted.data</span>, lag <span class="op">=</span> <span class="fl">1</span>, plot.pkg <span class="op">=</span> <span class="st">"base"</span><span class="op">)</span></span></code></pre></div>
<p><img src="structures_files/figure-html/unnamed-chunk-22-1.png" width="700"></p>
<p>It is relevant to point out that the choice of <code>R1</code> can
affect the final fit, as such, we highly recommend the user to perform a
sensibility analysis to help specify the value of <code>R1</code>.</p>
<p>Lastly, as we will see latter on, the noise block can also be useful
to model the dependency between multiple time series.</p>
</div>
<div class="section level2">
<h2 id="handling-multiple-structural-blocks">Handling multiple structural blocks<a class="anchor" aria-label="anchor" href="#handling-multiple-structural-blocks"></a>
</h2>
<p>In the previous subsections, we discussed how to define the structure
of a model using the functions <code>polynomial_block</code>,
<code>regression_block</code>, <code>harmonic_block</code>,
<code>AR_block</code> and <code>noise_block</code>, yet we have dealt
mostly with cases where a model had only one of those structures.
Generally, the user will want to mix and match multiple types of
structures, each one being responsible to explain part of the outcome
<span class="math inline">\(Y_t\)</span> (as seen in the case of the
<code>noise_block</code> function). For this task, we introduce two
operator: one to combine (superposition) and other to multiple
blocks.</p>
<p>Suppose that we have a model with a variety of structural blocks such
that:</p>
<p><span class="math display">\[
\begin{align}
\theta_t&amp;=\begin{bmatrix}\theta_t^1\\ \vdots\\
\theta_t^n\end{bmatrix}\\
F_t&amp;=\begin{bmatrix}F_t^1 &amp; \dots &amp; F_t^n\end{bmatrix}\\
G_t&amp;=diag\{G_t^{1},...,G_t^{n}\},\\
W_t&amp;=diag\{W_t^{1},...,W_t^{n}\},
\end{align}
\]</span> where <span class="math inline">\(diag\{M^1,...,M^{n}\}\)</span> represents a block
diagonal matrix such that its diagonal is composed of <span class="math inline">\(M^1,...,M^{n}\)</span>; <span class="math inline">\(\theta_t\)</span> is the vector obtained by the
concatenation of the vectors <span class="math inline">\(\theta_t^1,...,
\theta_t^n\)</span>; and <span class="math inline">\(F_t\)</span> is a
matrix obtained by the column-wise concatenation of the matrices <span class="math inline">\(F_t^1,..., F_t^n\)</span> (remember that each line
of <span class="math inline">\(F_t\)</span> correspond to one linear
predictor, such that <span class="math inline">\(F_t^1,...,
F_t^n\)</span> all have the same number of lines).</p>
<p>In this scenario, to facilitate the specification of such model, we
could create one structural block for each <span class="math inline">\(\theta_t^i\)</span>, <span class="math inline">\(F_t^{i}\)</span>, <span class="math inline">\(G_t^{i}\)</span> and <span class="math inline">\(W_t^{i}\)</span>, <span class="math inline">\(i=1,...n\)</span>, and then “combine” all blocks
together. This operation is called <em>superposition</em> and can be
found described in details in <span class="citation">West and Harrison
(<a href="#ref-WestHarr-DLM">1997</a>)</span>, section 6.2. Our package
allows that operation through the function <code>block_superpos</code>
or, (almost always) equivalently, through the <code>+</code>
operator:</p>
<p>To demonstrate the usage of this operator, suppose we would like to
create a model using four of the structures presented in the previous
sections (a polynomial trend, an dynamic regression, a harmonic trend
and an AR model). We could do so with the following code:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">poly_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Poly"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.95</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">regr_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/regression_block.html">regression_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="va">X</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Regr"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.95</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">harm_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/harmonic_block.html">harmonic_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  period <span class="op">=</span> <span class="fl">12</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Harm"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.975</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">AR_subblock</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/AR_block.html">AR_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  noise.var <span class="op">=</span> <span class="fl">0.1</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"AR"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">complete_block</span> <span class="op">&lt;-</span> <span class="va">poly_subblock</span> <span class="op">+</span> <span class="va">regr_subblock</span> <span class="op">+</span> <span class="va">harm_subblock</span> <span class="op">+</span> <span class="va">AR_subblock</span></span></code></pre></div>
<p>Ideally, the user should provide each block with a name to help
identify them after the model is fitted, but, if the user does not
provide a name, the block will have the default name for that type of
block. In case one or more blocks have the same name, the package will
automatically add an index to the variables with conflicting names based
on the order that the blocks were combined. Note that the automatic
naming might make the analysis of the fitted model confusing, specially
when dealing with a large number of latent variable, with that in mind,
we <strong>strongly</strong> recommend the users to specify an intuitive
name for each structural block.</p>
<p>Lastly, we present the <code>block_mult</code> function and the
associated operator <code>*</code>. This function allows the user to
create multiple blocks with identical structure, but each one being
associated with a different linear predictor. The usage of this function
is as simple as:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">base.block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span></span>
<span>  eta <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  order <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  name <span class="op">=</span> <span class="st">"Poly"</span>,</span>
<span>  D <span class="op">=</span> <span class="fl">0.95</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">final.block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/block_mult.html">block_mult</a></span><span class="op">(</span><span class="va">base.block</span>, <span class="fl">4</span><span class="op">)</span></span>
<span><span class="co"># or</span></span>
<span><span class="va">final.block</span> <span class="op">&lt;-</span> <span class="fl">4</span> <span class="op">*</span> <span class="va">base.block</span></span>
<span><span class="co"># or</span></span>
<span><span class="va">final.block</span> <span class="op">&lt;-</span> <span class="va">base.block</span> <span class="op">*</span> <span class="fl">4</span></span></code></pre></div>
<p>When multiplying blocks, the package understands that each copy of
the base block is independent of each other (i.e., they have their own
latent states) and each block is associated with a different set of
linear predictors. The name of the linear predictors associated with
each block are taken to be the original name with a index:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">final.block</span> <span class="op">&lt;-</span> <span class="fl">4</span> <span class="op">*</span> <span class="va">base.block</span></span>
<span><span class="va">final.block</span><span class="op">$</span><span class="va">pred.names</span></span></code></pre></div>
<pre><code>[1] "eta.1" "eta.2" "eta.3" "eta.4"</code></pre>
<p>Naturally, the user might want to rename the linear predictors to a
more intuitive label. For such task, we provide the
<code>rename_block</code> function, whose usage is as follows:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">final.block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/block_rename.html">block_rename</a></span><span class="op">(</span><span class="va">final.block</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Matthew"</span>, <span class="st">"Mark"</span>, <span class="st">"Luke"</span>, <span class="st">"John"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">final.block</span><span class="op">$</span><span class="va">pred.names</span></span></code></pre></div>
<pre><code>[1] "Matthew" "Mark"    "Luke"    "John"   </code></pre>
</div>
<div class="section level2">
<h2 id="handling-multiple-linear-predictors">Handling multiple linear predictors<a class="anchor" aria-label="anchor" href="#handling-multiple-linear-predictors"></a>
</h2>
<p>As the user may have noticed, more then one argument can be passed in
the <code>...</code> argument, indeed, if the user does so, the package
will create multiple linear predictors in the same block (one for each
unique name), all of which are affected by the associated latent state.
For instance, take the following code:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>The code above creates <span class="math inline">\(3\)</span> linear
predictors, such that:</p>
<p><span class="math display">\[
\lambda_{1,t}=1 \times \theta_{t}\\
\lambda_{2,t}=1 \times \theta_{t}\\
\lambda_{3,t}=1 \times \theta_{t}\\
\]</span></p>
<p>Naturally, in this simple case all linear predictors are identical,
but it does not need to be so, for instance:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">5</span>, lambda3 <span class="op">=</span> <span class="va">X</span><span class="op">)</span> <span class="co"># Assuming there is an variable X in the environment</span></span></code></pre></div>
<p>This code will create <span class="math inline">\(3\)</span> linear
predictors, such that:</p>
<p><span class="math display">\[
\begin{align}
\lambda_{1,t}&amp;=1 \times \theta_{t}\\
\lambda_{2,t}&amp;=5 \times \theta_{t}\\
\lambda_{3,t}&amp;=X_t \times \theta_{t}\\
\end{align}
\]</span></p>
<p>Also, one can use multiple blocks in the same structure to define
linear predictors that share some (but not all) of their components:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_1</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_2</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_3</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda2 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># theta_4</span></span></code></pre></div>
<p>Such that:</p>
<p><span class="math display">\[
\begin{align}
\lambda_{1,t}&amp;=\theta_{1,t}+\theta_{4,t}\\
\lambda_{2,t}&amp;=\theta_{2,t}+\theta_{4,t}\\
\lambda_{3,t}&amp;=\theta_{3,t}+\theta_{4,t}\\
\end{align}
\]</span></p>
<p>And also, the user may specify unknown components in the matrix <span class="math inline">\(F_t\)</span>, such as to estimate the impact of
some of the shared components:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda1 <span class="op">=</span> <span class="fl">1</span>, lambda3 <span class="op">=</span> <span class="st">"lambda2"</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_1</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda2 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="co"># theta_2</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda3 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># theta_3</span></span></code></pre></div>
<p><span class="math display">\[
\begin{align}
\lambda_{1,t}&amp;=\theta_{1,t}\\
\lambda_{2,t}&amp;=\theta_{2,t}\\
\lambda_{3,t}&amp;=\theta_{3,t}+\lambda_{2,t}\theta_{1,t}=\theta_{2,t}\theta_{1,t}\\
\end{align}
\]</span></p>
<p>More details about this last example are presented in the following
subsection.</p>
</div>
<div class="section level2">
<h2 id="handling-unknown-components-in-the-planning-matrix-f_t">Handling unknown components in the planning matrix <span class="math inline">\(F_t\)</span><a class="anchor" aria-label="anchor" href="#handling-unknown-components-in-the-planning-matrix-f_t"></a>
</h2>
<p>In some situations the user may want to fit a model such that:</p>
<p><span class="math display">\[
\require{color}
\begin{align}
\lambda_{t}=F_t'\theta_t=\cdots+\phi_t\theta_t +\cdots,
\end{align}
\]</span> in other words, it may be the case that the planning matrix
<span class="math inline">\(F_t\)</span> contains one or more unknown
components. This idea may be foreign when working with only one linear
predictor, but if our observational model has several parameters it
could make sense to have shared effects between parameters. Beside that,
this construction is also natural when modeling multiple time series
simultaneously, such as when dealing with correlated outcomes or when
working with a compound regression. All those cases will be explored in
the Advanced Examples section. For now, we will focus on
<strong>how</strong> to specify such models, whatever they use may
be.</p>
<p>For simplicity, let us assume that we want to create a linear
preditor <span class="math inline">\(\lambda_t\)</span> such that <span class="math inline">\(\lambda_{t}=\phi_t\theta_t\)</span>. Then the
first step would be to create a linear predictor associated with <span class="math inline">\(\phi_t\)</span> (which we will call
<code>phi</code>, although the user may call it whatever it pleases
him):</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">phi_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>phi <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>Notice that we are creating a linear predictor <span class="math inline">\(\phi_t\)</span> and a latent variable <span class="math inline">\(\tilde{\theta}_t\)</span> such that <span class="math inline">\(\phi_t=1\times \tilde{\theta}_t\)</span>. Also, it
is important to note that the structure for <span class="math inline">\(\phi_t\)</span> could be any of the other
structural blocks (harmonic, regression, autoregression, etc.).</p>
<p>Now we can create a structural block for <span class="math inline">\(\theta_t\)</span>:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">theta_block</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="st">"phi"</span><span class="op">)</span></span></code></pre></div>
<p>The code above creates a linear predictor <span class="math inline">\(\lambda_t\)</span> and a latent state <span class="math inline">\(\theta_t\)</span> such that <span class="math inline">\(\lambda_t=\phi_t \times \theta_t\)</span>. Notice
that the <code>...</code> argument of any structural block is used to
specify the planning matrix <span class="math inline">\(F_t\)</span>,
specifically, the user must provide a list of named values, whose name
indicate a linear predictor <span class="math inline">\(\lambda_t\)</span> and its associated value
represent the effect of <span class="math inline">\(\theta_{t}\)</span>
in this predictor. When the user pass a string in <code>...</code>, the
package understand that the component of <span class="math inline">\(F_t\)</span> associated with <span class="math inline">\(\theta_t\)</span> is unknown and is being modeled
by the linear predictor whose name is the passed string.</p>
<p>Lastly, as one could guess, it is possible to create a chain of
components in <span class="math inline">\(F_t\)</span> such as to create
an even more complex structure. For instance, take the code bellow:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta1 <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta2 <span class="op">=</span> <span class="st">"eta1"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>eta3 <span class="op">=</span> <span class="st">"eta2"</span><span class="op">)</span></span></code></pre></div>
<p>In the first line we create a linear predictor <span class="math inline">\(\eta_{1,t}\)</span> such that <span class="math inline">\(\eta_{1,t}=1 \times \theta_{1,t}\)</span>. In
second line we create another linear predictor <span class="math inline">\(\eta_{2,t}\)</span> such that <span class="math inline">\(\eta_{2,t}=\eta_{1,t} \times
\theta_{2,t}=\theta_{1,t} \times \theta_{2,t}\)</span>. Then we create a
linear predictor <span class="math inline">\(\eta_{3,t}\)</span> such
that <span class="math inline">\(\eta_{3,t}=\eta_{2,t} \times
\theta_{3,t}=\theta_{1,t} \times \theta_{2,t} \times
\theta_{3,t}\)</span>.</p>
</div>
<div class="section level2">
<h2 id="special-priors">Special priors<a class="anchor" aria-label="anchor" href="#special-priors"></a>
</h2>
<p>The user may want to specify some special priors that impose a
certain structure for the data. For instance, the user may believe that
a certain set of latent variable sum to <span class="math inline">\(0\)</span> or that there is a spacial structure to
them. This is specially relevant when modelling multiple time series,
for instance, lets say that we have <span class="math inline">\(r\)</span> series <span class="math inline">\(Y_{i,t}\)</span>, <span class="math inline">\(i=1,...r\)</span>, such that:</p>
<p><span class="math display">\[
\begin{aligned}    
Y_{i,t}|\eta_{i,t} &amp;\sim Poisson(\eta_{i,t})\\
\ln(\eta_{i,t})&amp;=\lambda_{it}=\mu_t+\alpha_{i,t},\\
\sum_{i=1}^{r} \alpha_{i,t}&amp;=0, \forall t.
\end{aligned}
\]</span></p>
<p>Similarly, one could want to specify a CAR prior <span class="citation">(<a href="#ref-AlexCar">Schmidt and Nobre
2018</a>)</span> for the variables <span class="math inline">\(\alpha_1,...\alpha_r\)</span>, if the user
believes there is spacial autocorrelation.</p>
<p>For those scenarios, the package offers some functions to modify the
prior of structural blocks, such as the <code>zero_sum_prior</code> and
the <code>CAR_prior</code>. Their general usage is very similar and can
be simply used as:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">structure</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="fl">5</span> <span class="op">*</span> <span class="fu"><a href="../reference/polynomial_block.html">polynomial_block</a></span><span class="op">(</span>mu <span class="op">=</span> <span class="fl">1</span>, D <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="../reference/zero_sum_prior.html">zero_sum_prior</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-AlexCar" class="csl-entry">
Schmidt, Alexandra M., and Widemberg S. Nobre. 2018. <span>“Conditional
Autoregressive (CAR) Model.”</span> In <em>Wiley StatsRef: Statistics
Reference Online</em>, 1–11. John Wiley &amp; Sons, Ltd.
https://doi.org/<a href="https://doi.org/10.1002/9781118445112.stat08048" class="external-link">https://doi.org/10.1002/9781118445112.stat08048</a>.
</div>
<div id="ref-WestHarr-DLM" class="csl-entry">
West, Mike, and Jeff Harrison. 1997. <em>Bayesian Forecasting and
Dynamic Models (Springer Series in Statistics)</em>. Hardcover;
Springer-Verlag.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Silvaneo dos Santos.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
