% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\name{fit_model}
\alias{fit_model}
\title{Fitting kDGLM models}
\usage{
fit_model(
  ...,
  outcomes,
  pred_cred = 0.95,
  smooth = TRUE,
  p_monit = NA,
  c_monit = 1
)
}
\arguments{
\item{...}{dlm_block object: The structural blocks of the model. All block must be completely defined.}

\item{outcomes}{List: The observed data. It should contain objects of the class dlm_distr.}

\item{pred_cred}{Numeric: A number between 0 and 1 (not included) indicating the credibility interval for predictions. If not within the valid range of values, predictions are not made.}

\item{smooth}{Bool: A flag indicating if the smoothed distribution for the latent variables should be calculated.}

\item{p_monit}{numeric (optional): The prior probability of changes in the latent space variables that are not part of it's dynamic.}

\item{c_monit}{numeric (optional, if p_monit is not specified): The relative cost of false alarm in the monitoring compared to the cost of not detecting abnormalities.}
}
\value{
A fitted_dlm object. Contains:
\itemize{
   \item mt Matrix: The filtered mean of the latent variables for each time. Dimensions are n x t.
   \item Ct Array: A 3D-array containing the filtered covariance matrix of the latent variable for each time. Dimensions are n x n x t.
   \item mts Matrix: The smoothed mean of the latent variables for each time. Dimensions are n x t. Only available if smooth=TRUE.
   \item Cts Array: A 3D-array containing the smoothed covariance matrix of the latent variable for each time. Dimensions are n x n x t. Only available if smooth=TRUE.
   \item at Matrix: The one-step-ahead mean of the latent variables at each time. Dimensions are n x t.
   \item Rt Array: A 3D-array containing the one-step-ahead covariance matrix for latent variables at each time. Dimensions are n x n x t.
   \item ft Matrix: The one-step-ahead linear predictor for each time. Dimensions are k x t.
   \item Qt Array: A 3D-array containing the one-step-ahead covariance matrix for the linear predictor for each time. Dimensions are k x k x t.
   \item FF Array: The same as the argument (same values).
   \item G Matrix: The same as the argument (same values).
   \item G_labs Matrix: The same as the argument (same values).
   \item D Array: The same as the argument (same values) when there is no monitoring. When monitoring for abnormalities, the value in times where abnormalities were detected is increased.
   \item h Matrix: A drift to be add after the temporal evolution (can be interpreted as the mean of the random noise at each time). Its dimension should be n x t, where t is the length of the series and n is the number of latent states.
   \item H Array: The same as the argument (same values).
   \item W Array: A 3D-array containing the effective covariance matrix of the noise for each time, i.e., considering both H and D. Its dimension should be the same as H and D.
   \item outcome List: The same as the argument outcome (same values).
   \item pred_names Vector: The names of the linear predictors.
   \item var_names List: A list containing names and indexes for latent variables.
   \item a1 Matrix: The prior mean for time 1. Dimensions are n x 1.
   \item R1 Matrix: The prior covariance matrix for time 1. Dimensions are n x n.
   \item smooth Bool: The same as the argument (same value).
   \item pred_cred Numeric: The same as the argument (same value).
   \item t Numeric: The time range for which the model has been fitted.
   \item structure dlm_block: The structure of the model. It's equivalent to block_superpos(...), but also taking into consideration the outcome length.
}
}
\description{
Fit a model given its structure and the observed data. This function can be used for any supported family (see vignette).
}
\details{
This is the main function of the kDGLM package, as it is used to fit all models.

For the details about the implementation see  \insertCite{ArtigoPacote;textual}{kDGLM}.

For the details about the methodology see  \insertCite{ArtigokParametrico;textual}{kDGLM}.

For the details about the Dynamic Linear Models see  \insertCite{WestHarr-DLM;textual}{kDGLM} and \insertCite{Petris-DLM;textual}{kDGLM}.
}
\examples{
library(kDGLM)

# Poisson case
T <- 200
w <- (T / 40) * 2 * pi
data <- rpois(T, exp(sin(w * 1:T / T) + 2))

level <- polynomial_block(rate = 1, D = 0.95)
season <- harmonic_block(rate = 1, period = 40, D = 0.98)

outcome <- Poisson(lambda = "rate", outcome = data)

fitted_data <- fit_model(level, season, outcomes = outcome)
summary(fitted_data)

show_fit(fitted_data, smooth = TRUE)$plot

##################################################################

# Multinomial case
T <- 200
y1 <- rpois(T, exp(5 + (-T:T / T) * 5))
y2 <- rpois(T, exp(6 + (-T:T / T) * 5 + sin((-T:T) * (2 * pi / 12))))
y3 <- rpois(T, exp(5))

y <- cbind(y1, y2, y3)

level <- polynomial_block(p1 = 1) + polynomial_block(p2 = 1)
season <- harmonic_block(p2 = 1, period = 12)
outcome <- Multinom(p = c("p1", "p2"), outcome = y)

fitted_data <- fit_model(level, season, outcomes = outcome)
summary(fitted_data)

show_fit(fitted_data, smooth = TRUE)$plot

##################################################################

# Normal case
T <- 200
mu <- rnorm(T, 0, 0.1)
data <- rnorm(T, cumsum(mu))

level <- polynomial_block(
  mu = 1,
  D = 0.95
)
variance <- polynomial_block(
  sigma2 = 1
)

# Known variance
outcome <- Normal(mu = "mu", Sigma = 1, outcome = data)

fitted_data <- fit_model(level, outcomes = outcome)
summary(fitted_data)

show_fit(fitted_data, smooth = TRUE)$plot

# Unknown variance
outcome <- Normal(mu = "mu", Sigma = "sigma2", outcome = data)

fitted_data <- fit_model(level, variance, outcomes = outcome)
summary(fitted_data)

show_fit(fitted_data, smooth = TRUE)$plot

##################################################################

# Gamma case
T <- 200
w <- (200 / 40) * 2 * pi
phi <- 2.5
mu <- exp(sin(w * 1:T / T) + 2)
data <- matrix(rgamma(T, phi, phi / mu), T, 1)

level <- polynomial_block(mu = 1, D = 0.95)
season <- harmonic_block(mu = 1, period = 40, D = 0.98)
scale <- polynomial_block(phi = 1, D = 1)

# Known shape
outcome <- Gamma(phi = phi, mu = "mu", outcome = data)

fitted_data <- fit_model(level, season, outcomes = outcome)
summary(fitted_data)

show_fit(fitted_data, smooth = TRUE)$plot

# DO NOT RUN
# # Unknown shape
# outcome <- Gamma(phi = "phi", mu = "mu", outcome = data)
#
# fitted_data <- fit_model(level, season, scale, outcomes = outcome)
# summary(fitted_data)
#
# show_fit(fitted_data, smooth = TRUE)$plot

}
\seealso{
auxiliary functions for creating outcomes \code{\link{Poisson}}, \code{\link{Multinom}}, \code{\link{Normal}}, \code{\link{Gamma}}, \code{\link{Dirichlet}}

auxiliary functions for creating structural blocks \code{\link{polynomial_block}}, \code{\link{harmonic_block}}, \code{\link{AR_block}}

auxiliary function for choosing hyper parameters \code{\link{search_model}}.

Other {auxiliary functions for fitted_dlm objects}: 
\code{\link{dlm_sampling}()},
\code{\link{eval_past}()},
\code{\link{forecast}()}
}
\concept{{auxiliary functions for fitted_dlm objects}}
